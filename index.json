[{"categories":null,"content":"学而时习 温故知新 ","date":"2021-07-18","objectID":"/posts/000000-hello-world/:0:1","tags":null,"title":"学习不能朝三暮四","uri":"/posts/000000-hello-world/"},{"categories":null,"content":"四问 这是什么？ 为什么要这样？ 可以不这样吗？ 有没有更好的方式？ ","date":"2021-07-18","objectID":"/posts/000000-hello-world/:0:2","tags":null,"title":"学习不能朝三暮四","uri":"/posts/000000-hello-world/"},{"categories":["服务器篇"],"content":"服务器内网穿透 https://github.com/fatedier/frp frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议，且支持 P2P 通信。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。 ","date":"2024-04-26","objectID":"/posts/20240426-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:0:0","tags":["linux","nodejs"],"title":"服务器内网穿透","uri":"/posts/20240426-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["服务器篇"],"content":"步骤 ","date":"2024-04-26","objectID":"/posts/20240426-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:0","tags":["linux","nodejs"],"title":"服务器内网穿透","uri":"/posts/20240426-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["服务器篇"],"content":"使用docker compose安装frps 在服务器创建一个目录 /opt/frp 在目录中创建两个文件 docker-compose.yml version: '3' services: frps: image: snowdreamtech/frps:0.49.0 container_name: frps restart: unless-stopped volumes: - ./frps.ini:/etc/frp/frps.ini network_mode: host [common] bind_port = 25999 token = EmQHpH2SP\u0026%6rq # 密码 dashboard_addr = 0.0.0.0 dashboard_port = 25998 dashboard_user = admin dashboard_pwd = EmQHpH2SP\u0026%6rq # 密码 在/opt/frp目录下 docker compose pull # 拉取docker compose文件中定义的服务所需的镜像 docker compose up -d # 启动compose容器 docker compose pull 用于拉取 Docker Compose 文件中定义的服务所需的镜像。当你在 Docker Compose 文件中定义了服务，并且这些服务的镜像还没有本地存在时，你可以使用该命令来下载这些镜像。 docker-compose up -d 是用于在 Docker Compose 环境中启动服务的命令，其中： -d 参数是指以“分离模式”（detached mode）运行，这意味着服务将在后台运行，而不会阻塞终端。 docker-compose up 命令会读取 docker-compose.yml 文件，并根据其中定义的服务配置启动容器。 查看容器日志 docker logs frps 检查防火墙，开放25998，25999端口 (云服务器也许去对应控制台放开) # 查看防火墙状态 systemctl status firewall # 关闭防火墙 systemctl stop firewalld 此时去服务器访问端口25998，可以看到登录页面，输入用户名和密码即可 ","date":"2024-04-26","objectID":"/posts/20240426-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:1","tags":["linux","nodejs"],"title":"服务器内网穿透","uri":"/posts/20240426-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["服务器篇"],"content":"windows服务器操作 下载对应frp应用 https://github.com/fatedier/frp 到对应frp下载目录中 修改相关frpc.toml配置文件 serverAddr = \"xxx.xxx.xxx.xxx\" # 服务器ip serverPort = 25999 auth.token = \"xxxx\" [[proxies]] name = \"应用名称自定义\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 3000 # 本地端口号 remotePort = 3000 # 远程端口号 启动 frpc -c frpc.toml ","date":"2024-04-26","objectID":"/posts/20240426-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:2","tags":["linux","nodejs"],"title":"服务器内网穿透","uri":"/posts/20240426-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["前端篇"],"content":"iframe间跨域通信 在 web 开发中，使用 iframe 进行通信是一种常见的技术，特别是在需要在页面中嵌入另一个页面或者来自不同域的内容时。通过 iframe 通信，父页面（包含 iframe 的页面）可以与 iframe 内的页面进行交互，以实现一些功能，比如传递数据、调用方法等。 接下来介绍下 PostMessage API + window.parent 来实现iframe父子之间信息传递，在此处父项目为vue3项目，iframe所在项目为react 父： import { useState } from 'react'; import './App.css' function App() { const [data, setData] = useState({ source: '', msg: '', rm: 0 }) const clickHandle = () =\u003e { window.parent.postMessage({ source: 'iframe', msg: 'message From iframe', rm: Math.random().toFixed(2) }, '*'); } //回调函数 function receiveMessageFromIndex(event: any) { setData(event.data) console.log('event', event.data); } //监听message事件 window.addEventListener(\"message\", receiveMessageFromIndex, false); return ( \u003c\u003e \u003cbutton onClick={clickHandle}\u003e子传父\u003c/button\u003e \u003ch1\u003e父数据：source: '{data.source}', msg: '{data.msg}', rm: {data.rm}\u003c/h1\u003e \u003c/\u003e ) } export default App 子： \u003cscript setup lang='ts'\u003e import { onMounted, ref } from 'vue'; const iframeRef = ref\u003cany\u003e() const iDom = ref\u003cHTMLElement\u003e() const iframeData = ref\u003cany\u003e({source: '', msg: '', rm: 0}) onMounted(() =\u003e { const iframeDom = document.getElementById('iframe') if (iframeDom) iDom.value = iframeDom if (!iframeDom) return // iframeDom.onload = function () { // //iframe加载完立即发送一条消息 // iframeDom.contentWindow.postMessage({ source: 'parent', msg: 'message From Parent' }, '*'); // } }) window.addEventListener(\"message\", (e) =\u003e { console.log('parent window listener', e.data); iframeData.value = e.data }, false); const clickHandle = () =\u003e { console.log('iframeRef', iframeRef.value.contentWindow, iDom); if (iDom.value) iDom.value.contentWindow.postMessage({ source: 'parent', msg: 'message From Parent', rm: Math.random().toFixed(2) }, '*'); } \u003c/script\u003e \u003ctemplate\u003e \u003ciframe ref=\"iframeRef\" id=\"iframe\" src=\"http://127.0.0.1:5173/\" style=\"width: 100%;height: 50vh;\" frameborder=\"0\"\u003e\u003c/iframe\u003e \u003cbutton @click=\"clickHandle\"\u003e父传子\u003c/button\u003e \u003ch1\u003e子数据 ：{{ iframeData }}\u003c/h1\u003e \u003c/template\u003e \u003cstyle scoped\u003e\u003c/style\u003e 即可实现iframe父子应用之间跨域通信 ","date":"2024-04-05","objectID":"/posts/20240405-iframe%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/:1:0","tags":["JavaScript"],"title":"Iframe跨域通信","uri":"/posts/20240405-iframe%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/"},{"categories":["前端篇"],"content":"下载相关npm包 { \"dependencies\": { \"@videojs-player/vue\": \"^1.0.0\", \"video.js\": \"^7.21.5\", \"videojs-contrib-hls\": \"^5.15.0\", \"vue-video-player\": \"^6.0.0\" }, \"devDependencies\": { \"@types/video.js\": \"^7.3.56\", }, } ","date":"2024-02-07","objectID":"/posts/20240207-videojs%E6%92%AD%E6%94%BE%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91/:0:1","tags":["JavaScript"],"title":"videojs播放流媒体视频","uri":"/posts/20240207-videojs%E6%92%AD%E6%94%BE%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91/"},{"categories":["前端篇"],"content":"前端相关vue3代码 \u003cscript setup lang=\"ts\"\u003e import videojs from 'video.js' import type { VideoJsPlayerOptions } from 'video.js' import 'video.js/dist/video-js.min.css' interface MyVideoProps { /** 视频地址 */ src: string } const props = withDefaults(defineProps\u003cMyVideoProps\u003e(), {}) // video标签 const videoRef = ref\u003cHTMLElement | null\u003e(null) // video实例对象 let videoPlayer: videojs.Player | null = null // video初始化完成的回调函数 const onPlayerReady = () =\u003e { } // 初始化videojs const initVideo = () =\u003e { // https://gitcode.gitcode.host/docs-cn/video.js-docs-cn/docs/guides/options.html const options: VideoJsPlayerOptions = { playbackRates: [0.5, 1.0, 1.5, 2.0], // 可选的播放速度 // aspectRatio: '4:3', // 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如\"16:9\"或\"4:3\"） language: 'zh-CN', // 设置语言 controls: true, // 是否显示控制条 preload: 'auto', // 预加载 loop: false, // 是否视频一结束就重新开始。 muted: false, // 默认情况下将会消除任何音频。 autoplay: true, // 是否自动播放 fluid: false, // 自适应宽高 src: props.src, // 要嵌入的视频源的源 URL // poster: '', // 封面地址 notSupportedMessage: '此视频暂无法播放，请稍后再试', // 允许覆盖Video.js无法播放媒体源时显示的默认信息。 controlBar: { timeDivider: true, // 当前时间和持续时间的分隔符 durationDisplay: true, // 显示持续时间 remainingTimeDisplay: true, // 是否显示剩余时间功能 fullscreenToggle: true, // 是否显示全屏按钮 }, } if (videoRef.value) { // 创建 video 实例 videoPlayer = videojs(videoRef.value, options, onPlayerReady) videoPlayer.src({ src: props.src, type: 'application/x-mpegURL', }) } } onMounted(() =\u003e { initVideo() }) onUnmounted(() =\u003e { videoPlayer?.dispose() }) \u003c/script\u003e \u003ctemplate\u003e \u003cvideo id=\"my-player\" ref=\"videoRef\" class=\"video-js w-full\" style=\"height: calc(100vh - 50px);\" /\u003e \u003c/template\u003e \u003cstyle lang=\"scss\" scoped\u003e .w-full { width: 100%; } :deep(.vjs-big-play-button) { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } \u003c/style\u003e src：视频地址，一般为可访问的静态目录，其中有目标视频的m3u8文件 ","date":"2024-02-07","objectID":"/posts/20240207-videojs%E6%92%AD%E6%94%BE%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91/:0:2","tags":["JavaScript"],"title":"videojs播放流媒体视频","uri":"/posts/20240207-videojs%E6%92%AD%E6%94%BE%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91/"},{"categories":["前端篇"],"content":"后端 需要将非m3u8格式的视频转成m3u8格式并放入服务器指定文件夹下 将文件夹暴露出去可以直接访问 ","date":"2024-02-07","objectID":"/posts/20240207-videojs%E6%92%AD%E6%94%BE%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91/:0:3","tags":["JavaScript"],"title":"videojs播放流媒体视频","uri":"/posts/20240207-videojs%E6%92%AD%E6%94%BE%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91/"},{"categories":["设计模式"],"content":" https://www.patterns.dev/vanilla/proxy-pattern ","date":"2024-01-22","objectID":"/posts/20240112-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式","JavaScript"],"title":"代理模式","uri":"/posts/20240112-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代理模式 通过代理对象，我们可以更好地控制与某些对象的交互.例如当我们获取或者设置值时,每当我们与对象交互代理对象就可以确定该对象地行为. 一般来说，代理人是指代替他人的人.你无需直接与该人交谈，而是与代表您试图联系的人的代理人交谈. JavaScript 中也会发生同样的情况：我们将与 Proxy 对象交互，而不是直接与目标对象交互. 让我们创建一个person对象来代表John Doe const person = { name: 'John Doe', age: 42, nationality: 'American' } 我们不想直接与该对象交互，而是希望与代理对象交互.在 JavaScript 中，我们可以通过创建 Proxy 的新实例来轻松创建新的代理. const person = { name: 'John Doe', age: 42, nationality: 'American' } const personProxy = new Proxy(person, {}) Proxy 的第二个参数是代表处理程序的对象。在处理程序对象中，我们可以根据交互类型定义特定的行为。尽管可以将许多方法添加到代理处理程序中，但最常见的两个是 get 和 set： get: 尝试访问属性时被调用 set: 尝试设置属性时被调用 实际上最终会发生一下情况 我们将与 personProxy 交互，而不是直接与 person 对象交互。 让我们向 personProxy 代理添加处理程序,当尝试修改属性，从而调用代理上的 set 方法时，我们希望代理记录属性的先前值和新值。当尝试访问属性，从而调用代理上的 get 方法时，我们希望代理记录一个更易读的句子，其中包含属性的键和值。 const personProxy = new Proxy(person, { get: (obj, prop) =\u003e { console.log(`The value of ${prop} is ${obj[prop]}`); }, set: (obj, prop, value) =\u003e { console.log(`Changed ${prop} from ${obj[prop]} to ${value}`); obj[prop] = value; }, }) 完美,让我们看看当我们尝试修改或检索属性时会发生什么. 当访问 name 属性时，Proxy 返回了一个听起来更好听的句子：The value of name is John Doe 修改年龄属性时，代理返回该属性的先前值和新值：将年龄从 42 更改为 43 代理对于添加验证很有用。用户不应该能够将人的年龄更改为字符串值，或给他们一个空名字。或者，如果用户尝试访问对象上不存在的属性，我们应该让用户知道。 让我们看看当我们尝试传递错误值时会发生什么！ 代理确保我们不会用错误的值修改 person 对象，这有助于我们保持数据的纯净！ ","date":"2024-01-22","objectID":"/posts/20240112-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式","JavaScript"],"title":"代理模式","uri":"/posts/20240112-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"反射 JavaScript 提供了一个名为 Reflect 的内置对象，它使我们在使用代理时更容易操作目标对象。 以前，我们尝试通过直接获取或设置带有括号表示法的值来修改和访问代理内目标对象的属性。相反，我们可以使用 Reflect 对象。 Reflect 对象上的方法与处理程序对象上的方法具有相同的名称。 我们可以通过 Reflect.get() 和 Reflect.set() 访问或修改目标对象的属性，而不是通过 obj[prop] 访问属性或通过 obj[prop] = value 设置属性。这些方法接收与处理程序对象上的方法相同的参数。 const personProxy = new Proxy(person, { get: (obj, prop) =\u003e { console.log(`The value of ${prop} is ${Reflect.get(obj, prop)}`); }, set: (obj, prop, value) =\u003e { console.log(`Changed ${prop} from ${obj[prop]} to ${value}`); Reflect.set(obj, prop, value); }, }); 完美,我们能通过Reflect对象轻易的修改和获取目标对象地值 ","date":"2024-01-22","objectID":"/posts/20240112-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:1","tags":["设计模式","JavaScript"],"title":"代理模式","uri":"/posts/20240112-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"权衡 代理是一种增强对对象行为的控制的强大方法。代理可以有各种用例：它可以帮助验证、格式化、通知或调试。 过度使用代理对象或对每个处理程序方法调用执行繁重的操作很容易对应用程序的性能产生负面影响。最好不要对性能关键型代码使用代理 ","date":"2024-01-22","objectID":"/posts/20240112-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:2","tags":["设计模式","JavaScript"],"title":"代理模式","uri":"/posts/20240112-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":" https://www.patterns.dev/vanilla/singleton-pattern ","date":"2024-01-03","objectID":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式","JavaScript"],"title":"单例模式","uri":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单例模式 单例是可以实例化一次就可以全局访问的类,这个创建出来的单例可以在整个应用中进行共享,这使得单例可以帮助应用管理全局状态 首先让我们看下在ES2015类写法中单例是长什么样子的,对于这个例子,我们将构建一个Counter类,它具有: getInstance 方法 来返回一个示例 getCount 方法 来返回 counter 变量 一个 increment 方法来使 counter 加一 一个 decrement 方法来使 counter 减一 let counter = 0; class Counter { getInstance() { return this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); console.log(counter1.getInstance() === counter2.getInstance()); // false 通过调用两次new方法,我们只是给counter1和counter2设置为不同的实例,counter1合counter2通过getInstance返回的值实际上是不同的实例引用,它们并不严格相等! 让我们来确保Counter只会创建一个实例 确保只会创建一个实例得方法是创建一个叫做instance得变量,在Counter的构造器中,当创建新的实例时,我们可以将instance设置为该实例的引用.我们可以通过判断instance是否有值来防止新实例的创建,如果是实例已经存在,这种情况下应该抛出一个异常来提示用户实例已存在 let counter = 0; let instance; class Counter { getInstance() { if (instance) { throw new Error(\"You can only create one instance!\") } instance = this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const counter1 = new Counter(); const counter2 = new Counter(); // Error: You can only create one instance! 完美!我们再也不能创建多个实例 现在我们将Counter实例1从counter.js中暴露出来,但是在行动之前,我们需要将该实例冻结,Object.freeze 方法确保使用代码无法修改单例. 处于冻结状态的实例无法添加或修改属性,这就降低了意外覆盖单例中值的风险操作 let counter = 0; let instance; class Counter { getInstance() { if (instance) { throw new Error(\"You can only create one instance!\") } instance = this; } getCount() { return counter; } increment() { return ++counter; } decrement() { return --counter; } } const singletonCounter = Object.freeze(new Counter()); export default singletonCounter 让我们看一下实现 Counter 示例的应用程序。我们有以下文件 counter.js 包含Counter类且默认导出一个Counter实例 index.js 加载 redButton.js 和 blueButton.js redButton.js 引入Counter ,添加Counter的increment方法作为红色按钮的监听器并通过调用 getCount 方法记录counter的当前值 blueButton.js 引入Counter ,添加Counter的increment方法作为蓝色按钮的监听器并通过调用 getCount 方法记录counter的当前值 redButton.js和blueButton.js从counter.js中引入了相同的实例,该实例在两个文件中均作为 Counter 导入。 不论我们从红色按钮或者蓝色按钮上调用 increment 方法,两个个文件中Counter实例上counter属性的值都会更新,这和我们点击红色或者蓝色的按钮无关,同一个值在所有的实例上共享,这就是为什么即使我们在不同的文件中调用该方法,计数器也会不断地加1 ","date":"2024-01-03","objectID":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式","JavaScript"],"title":"单例模式","uri":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"折中 将实例化限制为仅一个实例可能会节省大量内存空间,我们不必每次都为新实例设置内存,而只需为一个实例设置内存,该实例在整个应用程序中都会被引用。然而，单例实际上被认为是一种反模式，并且应该在 JavaScript 中避免。 在java,c++等一些编程语言中不可能像javascript中那样直接创建对象,在那些面向对象的编程语言中，我们需要创建一个类，这个类会创建一个对象。创建的对象具有类实例的值，就像 JavaScript 示例中的实例值一样。 ","date":"2024-01-03","objectID":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:1","tags":["设计模式","JavaScript"],"title":"单例模式","uri":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用常规对象 让我们使用之前看到的相同示例。然而这一次，counter 只是一个包含以下内容的对象： 一个 count 属性 一个 increment 方法来使count加一 一个 decrement 方法来使count减一 由于对象是通过引用传递的,因此redButton和blueButton都导入对同一计数器对象的引用,修改这两个文件中的count值都会修改counter上的值,该值在这两个文件中都可见 ","date":"2024-01-03","objectID":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:2","tags":["设计模式","JavaScript"],"title":"单例模式","uri":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"测试 测试依赖于单例的代码可能会有点棘手.由于我们无法每次都创建新的实例,因此所有测试都依赖于对上一次测试的全局实例的修改.在这种情况下测试的顺序很重要,一个小的修改可能会导致整个测试套件的失败.测试完成后,我们需要重置整个实例,以重置测试所做的修改. ","date":"2024-01-03","objectID":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:3","tags":["设计模式","JavaScript"],"title":"单例模式","uri":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"依赖隐藏 当导入另一个模块(本例中为superCounter.js)时,模块导入Singleton可能并不明显,在其他的文件中,例如本例中的index.js.我们可能会导入该模块并调用其方法.这样我们就无意中修改了Singleton中的值.这可能会导致以外的行为,因为单例的多个实例可以在整个应用程序中共享,这些实例也都会被修改. ","date":"2024-01-03","objectID":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:4","tags":["设计模式","JavaScript"],"title":"单例模式","uri":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"全局行为 Singleton的实例应该能在整个应用中被引用,全局的变量本质上会展示出相同的行为,由于全局变量在全局范围内可用因此我们可以在整个应用程序中访问这些变量. 拥有全局变量通常被认为试一个糟糕的设计决策,全局范围污染最终可能会意外覆盖全局变量的值,这可能会导致许多的意外行为. 在ES2015中创建全局变量变得相当少见,let和const通过将使用这两个关键字声明的变量保存在块范围内,可以防止开发人员意外污染全局范围 JavaScript中新的模块系统能够从模块到处值并且将这些值导入其他文件,从而更轻松地创建全局可访问的值,而不会午饭全局范围 然而单例的常见用例是在整个应用程序中拥有某种全局状态.让代码库的多个部分依赖于同一个可变对象,可能会导致意外的行为 通常,代码库的某些部分会修改全局状态的值,而其他部分则使用该数据,这里的执行顺序很重要,我们不想在没有数据可供使用时意外地首先使用数据!随着应用程序的增长,并且数十个组件相互依赖,理解使用全局状态时的数据流可能会变得非常棘手. ","date":"2024-01-03","objectID":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:5","tags":["设计模式","JavaScript"],"title":"单例模式","uri":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"react中的状态管理 在 React 中，我们经常通过 Redux 或 React Context 等状态管理工具来依赖全局状态，而不是使用单例。尽管它们的全局状态行为可能看起来与单例的行为类似，但这些工具提供只读状态而不是单例的可变状态。使用 Redux 时，在组件通过调度程序发送操作后，只有纯函数reducers才能更新状态。 尽管使用这些工具并不会神奇地消除全局状态的缺点，但我们至少可以确保全局状态按照我们预期的方式发生变化，因为组件无法直接更新状态。 ","date":"2024-01-03","objectID":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:6","tags":["设计模式","JavaScript"],"title":"单例模式","uri":"/posts/20240103-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["服务器篇"],"content":"镜像下载 CentOS 7 镜像 : CentOS-7-x86_64-DVD-2009.iso ","date":"2023-12-12","objectID":"/posts/20231212-vmware%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E4%BD%BF%E7%94%A8finalshell%E8%BF%9E%E6%8E%A5/:1:0","tags":["linux"],"title":"VMWare安装虚拟机并使用finalshell连接","uri":"/posts/20231212-vmware%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E4%BD%BF%E7%94%A8finalshell%E8%BF%9E%E6%8E%A5/"},{"categories":["服务器篇"],"content":"虚拟机创建 创建时点击下一步即可 在最后一步进入自定义硬件 在 新CD/DVD(IDE)处选择已安装的镜像 安装好镜像后打开虚拟机根据提示进行系统安装,此时需要记住用户名和密码 安装好后在系统中输入用户名密码登录 输入ip a查看IP信息 [root@localhost ~]# ip a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 输入下方命令进入文件编辑页面 vi /etc/sysconfig/network-scripts/ifcfg-ens33 将下方的ONBOOT属性改为yes TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=dhcp DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx DEVICE=ens33 ONBOOT=yes 重启虚拟机,再次输入ip a [root@localhost ~]# ip a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: ens33: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:86:60:8b brd ff:ff:ff:ff:ff:ff inet 192.168.111.4/24 brd 192.168.1.255 scope global noprefixroute dynamic ens33 valid_lft 603794sec preferred_lft 603794sec inet6 fe80::ed92:5253:424e:58b5/64 scope link noprefixroute valid_lft forever preferred_lft forever 此时宿主机和虚拟机尝试ping ip地址,如未ping 通可关闭防火墙 ","date":"2023-12-12","objectID":"/posts/20231212-vmware%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E4%BD%BF%E7%94%A8finalshell%E8%BF%9E%E6%8E%A5/:2:0","tags":["linux"],"title":"VMWare安装虚拟机并使用finalshell连接","uri":"/posts/20231212-vmware%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E4%BD%BF%E7%94%A8finalshell%E8%BF%9E%E6%8E%A5/"},{"categories":["服务器篇"],"content":"finalshell连接 finalshell连接是可能会出现java.net.ConnectException: Connection refused报错,这个原因可能是宿主机和虚拟机不在同一个网段导致,我们需要在VMWare虚拟网络编辑器中新建一个VMnet0为桥接模式,vmnet信息中选中桥接模式将虚拟机连接到外部网络,桥接到宿主机上,同时编辑虚拟机机配置,网络适配器-\u003e网络连接-\u003e自定义虚拟网络为刚刚我们设置的VMnet0 如果在设置桥接时提示无法将网络更改为桥接状态可以在卸载页面更改VMWare应用,对该应用进行修复,重新启动后即可 进行完上述操作即可在finalshell中,对VMWare我们创建的CentOS虚拟机进行连接 ","date":"2023-12-12","objectID":"/posts/20231212-vmware%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E4%BD%BF%E7%94%A8finalshell%E8%BF%9E%E6%8E%A5/:3:0","tags":["linux"],"title":"VMWare安装虚拟机并使用finalshell连接","uri":"/posts/20231212-vmware%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E4%BD%BF%E7%94%A8finalshell%E8%BF%9E%E6%8E%A5/"},{"categories":["前端篇"],"content":" 参考文章 手把手教你写一个简易的微前端框架-谭光志 参考仓库 mini-single-spa 本篇文章为学习微前端有感,只为记录微前端简短理解只实现了v1\u0026v2版本,深度以及广度完全不及大佬文章 ","date":"2023-11-09","objectID":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/:0:0","tags":["微前端"],"title":"简单理解微前端","uri":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"categories":["前端篇"],"content":"微前端是什么 微前端是一种软件架构模式，旨在将前端应用程序拆分为更小的、可独立开发、部署和维护的微服务单元。与传统的单体前端应用不同，微前端允许团队独立开发和部署其特定的前端功能模块，这些模块可以独立运行，也可以与其他模块协同工作，形成一个完整的前端应用 ","date":"2023-11-09","objectID":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/:1:0","tags":["微前端"],"title":"简单理解微前端","uri":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"categories":["前端篇"],"content":"微前端应用运行原理 微前端分主应用和子应用,在主应用中来注册子应用,通过监听路由的变化来挂载或者卸载子应用,从这里可知,子应用都有其对应的生命周期 ","date":"2023-11-09","objectID":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/:2:0","tags":["微前端"],"title":"简单理解微前端","uri":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"categories":["前端篇"],"content":"子应用注册 我们需要暴露出一个方法来使主应用注册子应用,并通过这个方法来接收到子应用的部分信息,如子应用名称,对应的路由地址,以及子应用生命周期函数等等 在微前端内部,通过一个数组来接收主应用注册的子应用,当子应用被注册时会进行应用状态的更新为启动前,并将注册的应用收集起来 /** * 该方法用来注册新的应用程序,并将应用程序的状态改为BEFORE_BOOTSTRAP(初始化状态) * @param app 所注册的应用 */ export default function registerApplication(app: Application) { console.log('app registerApplication', app) if (typeof app.activeRule === 'string') { const path = app.activeRule /** * 并且判断activeRule是否为字符串,如果 app.activeRule 是一个字符串， * 代码将它赋值给一个新的函数 app.activeRule，这个函数会接受一个 location 参数 * （默认为 window.location），并检查当前页面的路径是否与传入的路径匹配。 * 这是为了将路径规则转换为一个可执行的条件函数。 * @param location 地址 * @returns */ app.activeRule = (location = window.location) =\u003e location.pathname === path } app.status = AppStatus.BEFORE_BOOTSTRAP apps.push(app) } ","date":"2023-11-09","objectID":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/:2:1","tags":["微前端"],"title":"简单理解微前端","uri":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"categories":["前端篇"],"content":"子应用加载 在子应用的加载中会根据获取到的应用的状态来进行加载 / 已注册应用集合 export const apps: Application[] = [] export async function loadApps() { // 获取状态为MOUNTED的应用 const toUnMountApp = getAppsWithStatus(AppStatus.MOUNTED) // 对状态为MOUNTED的应用调用unMountApp方法 进行应用程序卸载 await Promise.all(toUnMountApp.map(unMountApp)) // 获取状态为BEFORE_BOOTSTRAP的应用 const toLoadApp = getAppsWithStatus(AppStatus.BEFORE_BOOTSTRAP) // 对状态为BEFORE_BOOTSTRAP的应用调用bootstrop函数 进行初始化 await Promise.all(toLoadApp.map(bootstrapApp)) const toMountApp = [ ...getAppsWithStatus(AppStatus.BOOTSTRAPPED), ...getAppsWithStatus(AppStatus.UNMOUNTED), ] await toMountApp.map(mountApp) } /** * 这个函数用于获取具有特定状态的应用程序的列表。它被多次调用， * 传入不同的 AppStatus 枚举值作为参数，从而获取不同状态的应用程序列表。 * 这可能是一个用于筛选应用程序的辅助函数。 * @param status 应用状态 * @returns */ function getAppsWithStatus(status: AppStatus) { // 收集筛选后的应用 const result: Application[] = [] apps.forEach((app) =\u003e { // tobootstrap or tomount if (isActive(app) \u0026\u0026 app.status === status) { switch (app.status) { case AppStatus.BEFORE_BOOTSTRAP: case AppStatus.BOOTSTRAPPED: case AppStatus.UNMOUNTED: result.push(app) break } } else if ( app.status === AppStatus.MOUNTED \u0026\u0026 status === AppStatus.MOUNTED ) { // tounmount result.push(app) } }) return result } function isActive(app: Application) { return typeof app.activeRule === 'function' \u0026\u0026 app.activeRule(window.location) } ","date":"2023-11-09","objectID":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/:2:2","tags":["微前端"],"title":"简单理解微前端","uri":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"categories":["前端篇"],"content":"路由监听 在路由监听这一层中,主要是对pushState,replaceState两个方法的重写,对这两个方法添加额外的行为,来进行子应用的加载或卸载, const originPushState = window.history.pushState const originReplaceState = window.history.replaceState export default function overwriteEventAndHistory() { window.history.pushState = function ( data: any, unused: string, url?: string | URL | null | undefined ): void { const result = originPushState.call(this, data, unused, url) loadApps() // 加载或卸载应用 return result } window.history.replaceState = function ( data: any, unused: string, url?: string | URL | null | undefined ) { const result = originReplaceState.call(this, data, unused, url) loadApps() // 加载或卸载应用 return result } window.addEventListener('popstate', () =\u003e { console.log('popstate') }) window.addEventListener('hashChange', () =\u003e { console.log('hashChange') }) } ","date":"2023-11-09","objectID":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/:2:3","tags":["微前端"],"title":"简单理解微前端","uri":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"categories":["前端篇"],"content":"生命周期 子应用的生命周期分为bootstrap,mount,unmount三个部分,启动,挂载和卸载 bootstrap bootstrap是用于启动应用程序的核心函数，负责应用程序的初始化和启动过程。 在此会先从对应的微前端应用中加载其声明的生命周期函数和属性,并对这些核心的声明周期函数进行校验,校验通过后将加载的生命周期函数赋值给对应的属性 接下来初始化应用的props,并执行应用程序的bootstrap函数,并处理结果 执行后修改应用的状态 mount 在mount执行时首先会将应用程序的状态改为挂载前,接下来调用应用的mount函数执行生命周期内的函数 执行修改应用的状态为挂载中 unmount 将应用程序的状态改为卸载前,执行函数的卸载操作,执行完后将应用程序状态改为已卸载 ","date":"2023-11-09","objectID":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/:2:4","tags":["微前端"],"title":"简单理解微前端","uri":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"categories":["前端篇"],"content":"简单注册使用 registerApplication({ name: 'vue', actionRule: '/vue', loadApp() { return Promise.resolve({ bootstrap() { console.log('vue bootstrap'); }, mount() { console.log('vue mount'); }, unmount() { console.log('vue unmount'); } }) } }) registerApplication({ name: 'react', actionRule: '/react', loadApp() { return Promise.resolve({ bootstrap() { console.log('react bootstrap'); }, mount() { console.log('react mount'); }, unmount() { console.log('react unmount'); } }) } }) ","date":"2023-11-09","objectID":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/:2:5","tags":["微前端"],"title":"简单理解微前端","uri":"/posts/20231109-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"categories":["前端篇"],"content":"为了实现前端预览pdf文件,在vue3和react中都进行了尝试 ","date":"2023-10-29","objectID":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/:0:0","tags":["Vue3","React"],"title":"前端实现PDF预览下载打印","uri":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/"},{"categories":["前端篇"],"content":"React ","date":"2023-10-29","objectID":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/:1:0","tags":["Vue3","React"],"title":"前端实现PDF预览下载打印","uri":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/"},{"categories":["前端篇"],"content":"react-pdf 在react中用到的组件是react-pdf,我们可以对组件进行二次封装来使组件支持放大,缩小,旋转,下载等功能 import { useState } from 'react'; import './styles.css'; import { Document, Page, pdfjs } from \"react-pdf\"; import { Spin, Watermark } from 'antd'; import { LeftCircleOutlined, RightCircleOutlined, ZoomInOutlined, ZoomOutOutlined, CompressOutlined, ExpandOutlined, CloseOutlined, LoadingOutlined, DownloadOutlined, RedoOutlined } from '@ant-design/icons' console.log('pdfjs.version', pdfjs.version); pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.js`; type OptionType = { show: boolean; url: string; } type SetOptionType = React.Dispatch\u003cReact.SetStateAction\u003cOptionType\u003e\u003e type Props = { option: OptionType, setOption: SetOptionType, WatermarkCon?: string, downLoadHandle?: () =\u003e void httpHeaders?: object | null | undefined; withCredentials?: boolean | null | undefined; } type AngleType = 0 | 90 | 180 | 270 const antIcon = \u003cLoadingOutlined style={{ fontSize: 24, color: 'white' }} spin /\u003e; // eslint-disable-next-line @typescript-eslint/no-explicit-any function throttle\u003cT extends (...args: any[]) =\u003e any\u003e(func: T, wait: number = 400): T { let timeout: ReturnType\u003ctypeof setTimeout\u003e | null = null; // eslint-disable-next-line @typescript-eslint/no-explicit-any let context: any; let args: IArguments | null; // eslint-disable-next-line @typescript-eslint/no-explicit-any const throttled = function (this: any) { // eslint-disable-next-line @typescript-eslint/no-this-alias context = this; // eslint-disable-next-line prefer-rest-params args = arguments; if (!timeout) { timeout = setTimeout(() =\u003e { // eslint-disable-next-line @typescript-eslint/no-explicit-any func.apply(context, args as any); timeout = null; }, wait); } }; return throttled as T; } const PdfPreview = ({ option, setOption, downLoadHandle, WatermarkCon, httpHeaders, withCredentials }: Props) =\u003e { const [pageNumber, setPageNumber] = useState(1) const [pageNumberInput, setPageNumberInput] = useState(1) const [pageNumberFocus, setPageNumberFocus] = useState(false) const [numPages, setNumPages] = useState(1) const [pageWidth, setPageWidth] = useState(503) const [fullscreen, setFullscreen] = useState(false) const [angle, setAngle] = useState\u003cAngleType\u003e(0) const cleanUp = () =\u003e { setPageNumber(1) setPageNumberInput(1) setPageNumberFocus(false) setNumPages(1) setPageWidth(503) setFullscreen(false) setAngle(0) } // eslint-disable-next-line @typescript-eslint/no-explicit-any const onDocumentLoadSuccess = (data: any) =\u003e { const totalPages = data['_transport']['_numPages'] || 1 setNumPages(totalPages) } const rotatePage = () =\u003e { setAngle((oldAngle) =\u003e { switch (oldAngle) { case 0: return 90 case 90: return 180 case 180: return 270 case 270: return 0 } }) } const downLoad = () =\u003e { downLoadHandle \u0026\u0026 downLoadHandle() } const lastPage = () =\u003e { if (pageNumber === 1) return; const page = pageNumber - 1; setPageNumber(page) setPageNumberInput(page) } const nextPage = () =\u003e { if (pageNumber === numPages) return; const page = pageNumber + 1; setPageNumber(page) setPageNumberInput(page) } const onPageNumberFocus = () =\u003e { setPageNumberFocus(true) } const onPageNumberBlur = () =\u003e { setPageNumberFocus(false) setPageNumberInput(pageNumber) } // eslint-disable-next-line @typescript-eslint/no-explicit-any const onPageNumberChange = (e: any) =\u003e { let value = Number(e.target.value); value = value \u003c= 0 ? 1 : value; value = value \u003e= numPages ? numPages : value; setPageNumber(value) setPageNumberInput(value) } // eslint-disable-next-line @typescript-eslint/no-explicit-any const toPage = (e: any) =\u003e { if (e.keyCode === 13) { setPageNumber(Number(e.target.value)) } } const pageZoomOut = () =\u003e { if (pageWidth \u003c= 503) return; setPageWidth((oldv) =\u003e oldv * 0.8) } const pageZoomIn = () =\u003e { setPageWidth((oldv) =\u003e oldv * 1.2) } const pageFullscreen = () =\u003e { if (fullscreen) { setFullscreen(false) setPageWidth(600) } else { setFullscreen(true) setPageWidth(window.screen.width - 40) } } // eslint","date":"2023-10-29","objectID":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/:1:1","tags":["Vue3","React"],"title":"前端实现PDF预览下载打印","uri":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/"},{"categories":["前端篇"],"content":"vue3 在vue3中尝试用过了两个组件 因为没有找到显示签名的具体解决办法,部分签名仍未显示,所以最后选择了pdfjs ","date":"2023-10-29","objectID":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/:2:0","tags":["Vue3","React"],"title":"前端实现PDF预览下载打印","uri":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/"},{"categories":["前端篇"],"content":"vue3-pdf-app https://www.npmjs.com/package/vue3-pdf-app vue3-pdf-app对vue-pdf-app做了vue3的兼容,是一个基于Vue 3和PDF.js的PDF阅读器组件，可以方便地在Vue应用程序中嵌入PDF文件并预览。 在vue3-pdf-app如果要预览pdf签名的话需要对下列代码进行注释 if (data.fieldType === \"Sig\") { data.fieldValue = null; // this.setFlags(_util.AnnotationFlag.HIDDEN); // 全局搜索_util.AnnotationFlag.HIDDEN 注释相关行代码 } ","date":"2023-10-29","objectID":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/:2:1","tags":["Vue3","React"],"title":"前端实现PDF预览下载打印","uri":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/"},{"categories":["前端篇"],"content":"pdfjs https://gitcode.gitcode.host/docs-cn/pdf.js-docs-cn/getting_started/index.html PDF.js是Mozilla开发的一个JavaScript库，用于在Web浏览器中解析和显示PDF文档。它允许开发人员将PDF文件嵌入到网页中，并使用JavaScript来控制PDF的呈现和交互。PDF.js的主要优点是它可以在任何支持JavaScript的浏览器中运行，不需要任何插件或下载。 我们可以使用pdfjs打包好的文件,通过iframe的方式来进行pdf的预览 使用pdfjs的原因是pdfjs打包后的文件可以完美的展示pdf签名, 进行简单封装 \u003cscript setup lang='ts'\u003e import { onMounted, ref } from 'vue'; const props = withDefaults( defineProps\u003c{ width: string, height: string, src: string | BlobPart }\u003e(), { width: \"100%\", height: \"100%\", src: '' } ) const pdfUrl = ref\u003cstring\u003e() onMounted(() =\u003e { if (typeof props.src === 'string') { pdfUrl.value = props.src } else { pdfUrl.value = window.URL.createObjectURL(new Blob([props.src])) } }) \u003c/script\u003e \u003ctemplate\u003e \u003ciframe v-bind=\"props\" :src=\"`./pdfjs/web/viewer.html?file=${props.src}`\" frameborder=\"0\"\u003e\u003c/iframe\u003e \u003c/template\u003e \u003cstyle scoped lang='less'\u003e\u003c/style\u003e 对于传入流式二进制文件将其转化为blob地址进行预览 仓库地址: https://github.com/Plumliil/pdf-preview 在线预览地址: https://pdf.plumliil.cn/ ","date":"2023-10-29","objectID":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/:2:2","tags":["Vue3","React"],"title":"前端实现PDF预览下载打印","uri":"/posts/20231029-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0pdf%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8D%B0/"},{"categories":["服务器篇"],"content":"最近想使用闲置服务器作为一个仓库来访问其中的静态资源,同时学习服务器相关知识,方便之后配置docker和nginx遂有此记录 ","date":"2023-10-27","objectID":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/:0:0","tags":["docker","nginx"],"title":"Nginx访问服务器静态资源","uri":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"categories":["服务器篇"],"content":"什么是docker Docker是一种基于Go语言实现的开源容器项目,目标是达到项目运行环境“一次封装，到处运行”的目的。 ","date":"2023-10-27","objectID":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/:0:1","tags":["docker","nginx"],"title":"Nginx访问服务器静态资源","uri":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"categories":["服务器篇"],"content":"什么是nginx Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。其占有内存少，并发能力强，在BSD-like 协议下发行。 ","date":"2023-10-27","objectID":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/:0:2","tags":["docker","nginx"],"title":"Nginx访问服务器静态资源","uri":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"categories":["服务器篇"],"content":"linux安装docker 我的服务器是 ubuntu-18.04-amd64 1 .检查卸载老版本docker sudo apt-get remove docker docker-engine http://docker.io containerd runc 2 .更新ubuntu的apt源索引 sudo apt-get update 3 .允许apt通过HTTPS使用仓库安装依赖 sudo apt-get install apt-transport-https ca-certificates curl software-properties-common 4 .添加GPG密钥 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 5 .加入官方仓库 echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 6 .安装docker sudo apt-get install docker-ce docker-ce-cli containerd.io 7 查看是否安装成功 sudo docker run hello-world 8 .docker卸载 sudo apt-get purge docker-ce docker-ce-cli containerd.io ","date":"2023-10-27","objectID":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/:0:3","tags":["docker","nginx"],"title":"Nginx访问服务器静态资源","uri":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"categories":["服务器篇"],"content":"docker安装及配置nginx 因为需要访问服务器的静态资源,所以最好将nginx容器内的配置文件等一些相关目录和宿主机相关联,将宿主机的目录映射到nginx容器里 1 .安装nginx镜像 docker pull nginx 2 .启动nginx docker run --name nginx -p 80:80 -d nginx 3 .创建宿主机nginx配置文件地址 mkdir -p home/nginx/conf.d/ \u0026 mkdir -p home/nginx/conf/ \u0026 mkdir -p home/nginx/html/ \u0026 mkdir -p home/nginx/logs/ \u0026 mkdir -p mnt/data/ -p 参数来创建多级文件夹 4 .查看nginx容器id docker ps -a 4 .将nginx容器中的相关配置文件拷贝到宿主机 docker cp 容器id:/etc/nginx/nginx.conf /home/nginx/conf/ docker cp 容器id:/etc/nginx/conf.d/default.conf /home/nginx/conf.d/ docker cp 容器id:/usr/share/nginx/html /home/nginx/html/ docker cp 容器id:/var/log/nginx /home/nginx/logs/ 5 .停止容器运行并删除容器 docker stop 容器id docker rm 容器id 6 .重新创建启动nginx容器并将容器配置文件挂载到宿主机 docker run --name nginx3344 -d -p 3344:80 -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /mnt/data:/mnt/data -v /home/nginx/logs:/var/log/nginx -v /home/nginx/html:/usr/share/nginx/html -v /home/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf nginx –name nginx3344：为新创建的Docker容器指定一个名字，这个名字是“nginx3344 -d：在后台运行容器。 -p 3344:80：将宿主机的3344端口映射到容器的80端口。这样，访问宿主机的3344端口就会自动转到容器的80端口。 -v 将宿主机的路径挂载到容器的同一路径。 nginx：这是要运行的Docker镜像的名称，它表示要运行的容器是用这个镜像创建的。 ","date":"2023-10-27","objectID":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/:0:4","tags":["docker","nginx"],"title":"Nginx访问服务器静态资源","uri":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"categories":["服务器篇"],"content":"静态资源访问配置 server { listen 80; # listen [::]:80; server_name localhost; #access_log /var/log/nginx/host.access.log main; location / { add_header Access-Control-Allow-Origin *; alias /mnt/data/; autoindex on; } # location ~ .*\\.(js|css|htm|html|gif|jpg|jpeg|png|bmp|ico|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$ { # root /mnt/data; # } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; # location = /50x.html { # root /usr/share/nginx/html; # } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # # location ~ \\.php$ { # proxy_pass http://127.0.0.1; # } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # # location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; # } # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # # location ~ /\\.ht { # deny all; # } } location / { add_header Access-Control-Allow-Origin *; alias /mnt/data/; autoindex on; } add_header Access-Control-Allow-Origin * 它用于在HTTP响应头中添加一个名为Access-Control-Allow-Origin的头部。星号(*)表示这个头部将允许任何来源的网页进行访问，这是CORS（跨源资源共享）策略的一部分，用于处理跨域请求。 alias 用于将服务器上的某个路径映射到另一个路径。在这里，它将服务器上的/mnt/data路径映射为网站的根目录 autoindex 它用于启用目录列表。如果请求的URL是一个目录且没有特定的处理指令，Nginx会自动返回该目录下的文件列表。 至此结束 ","date":"2023-10-27","objectID":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/:0:5","tags":["docker","nginx"],"title":"Nginx访问服务器静态资源","uri":"/posts/20231026-nginx%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"categories":["前端篇"],"content":"最近学习TS类型体操,其中用到了例如 keyof infer等的关键字,但在日常项目中又不太常用,故有此记录,方便查阅 ","date":"2023-10-17","objectID":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/:0:0","tags":["Typescript","类型体操"],"title":"TypeScript中关键字介绍","uri":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/"},{"categories":["前端篇"],"content":"extends 用于类型的继承 interface Animal { name:string color:string gender:'male' | 'female' } interface Duck extends Animal{ sound:string } const duck:Duck={ name:'tang', color:'yellow', gender:'male', sound:'gaga' } 上述代码中Duck继承了父类型,并且又声明了自己独有的类型 用于类型的推断 type Test1 = 'a' | 'b' | 'c' type Test2 = 'a' | 's' type MyExclude\u003cT, U\u003e = T extends U ? never : T; type TestType = MyExclude\u003cTest1, Test2\u003e const t: TestType = 'b' 当extends两边是联合类型时,就会遵守分配律的规则拆分左侧联合类型,依次来判断拆分后的类型是否满足继承关系,再通过判断继续联合 以上述代码为例 'a' extends 'a' | 's' true never 'b' extends 'a' | 's' false 'b' 'c' extends 'a' | 's' false 'c' 最终TestType的类型是'b' | 'c' ","date":"2023-10-17","objectID":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/:0:1","tags":["Typescript","类型体操"],"title":"TypeScript中关键字介绍","uri":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/"},{"categories":["前端篇"],"content":"keyof keyof用来获取对象类型的所有键的联合类型 interface Test { name: string color: string } type TestType = keyof Test // \"name\"|\"color\" const t1: TestType = \"name\" const t2: TestType = \"color\" // const t3: TestType = \"gender\" // 不能将类型“\"gender\"”分配给类型“keyof Test”。 ","date":"2023-10-17","objectID":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/:0:2","tags":["Typescript","类型体操"],"title":"TypeScript中关键字介绍","uri":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/"},{"categories":["前端篇"],"content":"infer infer是typescript中的高级类型关键字,通常与条件类型一起使用,用于从已知类型中推断出其他类型,允许在类型级别执行复杂的条件分支和推断操作 type First\u003cT extends any[]\u003e = T extends [infer U, ...any[]] ? U : never; type FirstType=First\u003c[3, 2, 1]\u003e const n:FirstType = 3 上述代码中infer的作用是推断出第一个数组的第一个元素的类型 ","date":"2023-10-17","objectID":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/:0:3","tags":["Typescript","类型体操"],"title":"TypeScript中关键字介绍","uri":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/"},{"categories":["前端篇"],"content":"readonly 在typescript中,readonly用于定义对象属性或数组元素为只读(不可修改)的类型 interface Persion { readonly IDCard: string readonly name: string age: number } const person: Persion = { IDCard: '136548862113647524', name: \"zhang\", age: 19 } person.name = 'wang'; // 无法为“name”赋值，因为它是只读属性 ","date":"2023-10-17","objectID":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/:0:4","tags":["Typescript","类型体操"],"title":"TypeScript中关键字介绍","uri":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/"},{"categories":["前端篇"],"content":"Exclude Exclude 是 TypeScript 中内置的一个类型修饰器，用于从一个类型中排除另一个类型。 interface Test1 { name: string color: string } interface Test2 { name: string } type TestType = Exclude\u003ckeyof Test1, keyof Test2\u003e const t1: TestType = \"name\" // 不能将类型“\"name\"”分配给类型“\"color\"”。 目前先记录到这里,该篇文章会继续更新… ","date":"2023-10-17","objectID":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/:0:5","tags":["Typescript","类型体操"],"title":"TypeScript中关键字介绍","uri":"/posts/20231017-typescript%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/"},{"categories":["前端篇"],"content":"useContext Context Hook 是可以让子组件给后代组件共享数据 接受一个上下文对象(从’ React.createContext ‘返回的值)并返回当前 context 值，该值由最近的给定上下文提供程序提供。 ","date":"2023-09-07","objectID":"/posts/20230907-react%E4%B8%ADusecontextusereducer%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:1","tags":["React"],"title":"React中useContext,useReducer简单实现全局状态管理","uri":"/posts/20230907-react%E4%B8%ADusecontextusereducer%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["前端篇"],"content":"useReducer useReducer 是 useState 的另一种选择,当我们要实现的状态逻辑较为复杂时,useReducer 优先级更高,还可以优化触发深度更新组件的性能,因为 useReduce 可以向下出传递 dispatch 而不是回调 useReducer 支持我们传递三个参数, 第一个参数是 reducer 纯函数 第二个参数是我们要使用的初始化值 第三个参数是一个函数,它支持我们对 useReducer 进行初始化操作 ","date":"2023-09-07","objectID":"/posts/20230907-react%E4%B8%ADusecontextusereducer%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:2","tags":["React"],"title":"React中useContext,useReducer简单实现全局状态管理","uri":"/posts/20230907-react%E4%B8%ADusecontextusereducer%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["前端篇"],"content":"实操 定义reducer函数 我们可以先通过useReducer来实现主题或者一些其他状态的收集以及修改,基本代码如下: export type State={ theme:'dark' | 'light' } export enum ActionType{ UPDATE=\"UPDATE\", } type UpdateAction={ type: ActionType field: string value: any } export type Action = UpdateAction const initStateStorage = JSON.parse(localStorage.getItem('mySiteState') || '{}') const initData: State={ theme:'dark', ...initStateStorage } export function reducer(state: State, action: Action) { switch (action.type) { case ActionType.UPDATE: localStorage.setItem('mySiteState', JSON.stringify({ ...state, [action.field]: action.value })) return { ...state, [action.field]: action.value } default: throw new Error() } } 上方代码中抽离出来了一个reducer函数来改变全局状态的值,并定义了一个初始化的状态,之后可以通过判断动作来进行状态的更新,并将状态储存到localStorage中实现持久化 定义上下文 接下来需要定义一个全局容器来提供状态,具体代码如下: import { Dispatch, ReactNode, createContext, useContext, useMemo, useReducer } from \"react\" import { Action, State, initState, reducer } from \"./reducers/AppReducer\" type AppContextProps = { state: State dispatch: Dispatch\u003cAction\u003e } const AppContext=createContext(null!) export function useAppContext(){ return useContext(AppContext) } export default function AppContextProvider({ children }: { children: ReactNode }) { const [state, dispatch] = useReducer(reducer, initState) // 把创建函数和依赖数组项作为参数传入 useMemo，它仅仅会在数组依赖项中的值改变时才会重新计算值 const contextValue = useMemo(() =\u003e { return { state, dispatch } }, [state, dispatch]) return \u003cAppContext.Provider value={contextValue}\u003e{children}\u003c/AppContext.Provider\u003e } 使用 在main.ts或是其他位置对App组件进行包裹,实现全局状态的使用 import React from 'react' import ReactDOM from 'react-dom/client' import App from './App.tsx' import AppContextProvider, { useAppContext } from './AppContext.tsx' const Container = () =\u003e { const { state: { theme } } = useAppContext() return ( \u003cdiv style={{ backgroundColor: theme === 'dark' ? 'black' : 'white', width: '100vw', height: '100vh' }}\u003e \u003cApp /\u003e \u003c/div\u003e ) } ReactDOM.createRoot(document.getElementById('root')!).render( \u003cReact.StrictMode\u003e \u003cAppContextProvider\u003e \u003cContainer /\u003e \u003c/AppContextProvider\u003e \u003c/React.StrictMode\u003e, ) 全局状态修改 import { useAppContext } from './AppContext' import { ActionType } from './reducers/AppReducer' function App() { const { state: { loading, theme }, dispatch } = useAppContext() const changeTheme = () =\u003e { if (theme === 'dark') { dispatch({ type: ActionType.UPDATE, field: 'theme', value: 'light' }) } else { dispatch({ type: ActionType.UPDATE, field: 'theme', value: 'dark' }) } } return ( \u003cbutton onClick={async () =\u003e changeTheme()}\u003e changeTheme \u003c/button\u003e ) } export default App ","date":"2023-09-07","objectID":"/posts/20230907-react%E4%B8%ADusecontextusereducer%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:0:3","tags":["React"],"title":"React中useContext,useReducer简单实现全局状态管理","uri":"/posts/20230907-react%E4%B8%ADusecontextusereducer%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["前端篇"],"content":"Ant Design 和 Ant Design Pro 可能是 React 选手在日常工作中接触最多的库了. 接下来就说说在工作用可能会用到但是不经常用,但用的时候会忘的一些属性或方法的使用 ","date":"2023-08-06","objectID":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/:0:0","tags":["React","AntD"],"title":"Antd及AntdPro组件使用积累","uri":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/"},{"categories":["前端篇"],"content":"Modal 自定义页脚按钮属性: 传入 okButtonProps 和 cancelButtonProps 可分别自定义确定按钮和取消按钮的 props。 参数 说明 类型 cancelButtonProps cancel 按钮 props ButtonProps okButtonProps ok 按钮 props ButtonProps \u003cModal title=\"cancelButtonProps 使用\" visible={true} cancelButtonProps={{ style: { display: \"none\", }, }} okButtonProps={{ style: { color: \"white\", backgroundColor: \"pink\", }, }} \u003e \u003ch1\u003e隐藏取消按钮\u003c/h1\u003e \u003c/Modal\u003e ","date":"2023-08-06","objectID":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/:0:1","tags":["React","AntD"],"title":"Antd及AntdPro组件使用积累","uri":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/"},{"categories":["前端篇"],"content":"ProTable import type { ProColumns, ProFormInstance } from \"@ant-design/pro-components\"; import { ProTable } from \"@ant-design/pro-components\"; import { useState } from \"react\"; export type TableListItem = { field: string; createdAt: string; }; const columns: ProColumns\u003cTableListItem\u003e[] = [ { title: \"我是字段1字段1字段1\", dataIndex: \"field\", }, { title: \"创建时间\", dataIndex: \"createdAt\", valueType: \"date\", }, ]; const data = [ { field: \"1\", createdAt: \"2023-08-05\", }, ]; export default () =\u003e { const [collapsed, setCollapsed] = useState(false); return ( \u003c\u003e \u003cProTable\u003cTableListItem\u003e style={{ margin: \"16px\", }} columns={columns} dataSource={data} rowKey=\"key\" pagination={{ showSizeChanger: true, }} search={{ labelWidth: \"auto\", collapsed, onCollapse: setCollapsed, }} options={false} dateFormatter=\"string\" /\u003e \u003c/\u003e ); }; 查询栏控制 通过 search 属性可以对 ProTable 表格进行查询配置 columns 中模糊查询配置 { title: \"类型\", dataIndex: \"selectKey\", valueType: \"select\", fieldProps: { showSearch: true, }, }, 通过配置 column 中 fieldProps 中 showSearch 属性可以进行模糊查询 labelWidth 如上图红框所示,字段长度过长,显示会出问题,此时可以 通过 labelWidth 对查询栏中的字段进行长度配置 search={{ labelWidth: \"auto\", }} collapsed 可收起查询字段配置 const [collapsed, setCollapsed] = useState(false); search={{ collapsed, onCollapse: setCollapsed, }} 表格嵌套 对于数据表格嵌套的实现可以借助 expandable 属性来实现 expandable={{ // 默认展开行 defaultExpandAllRows: true, // 展开行渲染 expandedRowRender: (record) =\u003e projectContentRender({ record }), }} 完整代码 import React, { useRef, useState } from \"react\"; import type { ActionType, ProColumns } from \"@ant-design/pro-table\"; import { data } from \"./data\"; import { ProCard, ProFormField, ProTable } from \"@ant-design/pro-components\"; function classifyProjectsByYearAndClassification(projects: any) { const classifiedProjects: any = []; for (const project of projects) { const yearEntry = classifiedProjects.find( (entry: any) =\u003e entry.title === project.grade ); if (!yearEntry) { classifiedProjects.push({ title: project.grade, data: { one: [], two: [], three: [], }, }); } const updatedYearEntry = classifiedProjects.find( (entry: any) =\u003e entry.title === project.grade ); updatedYearEntry.data[project.class].push(project); } return classifiedProjects; } const StudentList = () =\u003e { const actionRef = useRef\u003cActionType\u003e(); const [expandedRowKeys, setExpandedRowKeys] = useState([\"高二\"]); // 设置初始展开的行的 key const dataSource = classifyProjectsByYearAndClassification(data); console.log(dataSource); const studentColumns: ProColumns[] = [ { title: \"姓名\", dataIndex: \"name\", align: \"center\", }, { title: \"语文\", dataIndex: \"subjectYuWen\", align: \"center\", }, { title: \"数学\", dataIndex: \"subjectShuXue\", align: \"center\", }, { title: \"英语\", dataIndex: \"subjectYingYu\", align: \"center\", }, { title: \"排名\", align: \"center\", dataIndex: \"ranking\", }, { title: \"班级\", dataIndex: \"class\", valueType: \"select\", align: \"center\", render: (val) =\u003e { return val === \"one\" ? \"一班\" : val === \"two\" ? \"二班\" : \"三班\"; }, }, { title: \"年级\", dataIndex: \"grade\", align: \"center\", valueType: \"select\", }, ]; const gradeColumns: ProColumns[] = [ { title: \"\", dataIndex: \"title\", align: \"center\", hideInSearch: true, }, { title: \"姓名\", dataIndex: \"name\", align: \"center\", hideInTable: true, }, { title: \"语文\", dataIndex: \"subjectYuWen\", align: \"center\", hideInTable: true, }, { title: \"数学\", dataIndex: \"subjectShuXue\", align: \"center\", hideInTable: true, }, { title: \"英语\", dataIndex: \"subjectYingYu\", align: \"center\", hideInTable: true, }, { title: \"排名\", align: \"center\", dataIndex: \"ranking\", hideInTable: true, }, { title: \"班级\", dataIndex: \"class\", valueType: \"select\", align: \"center\", hideInTable: true, render: (val) =\u003e { return val === \"one\" ? \"一班\" : val === \"two\" ? \"二班\" : \"三班\"; }, }, { title: \"年级\", dataIndex: \"grade\", align: \"center\", hideInTable: true, valueType: \"select\", }, ]; const classColumns: ProColumns[] = [ { title: \"\", dataIndex: \"title\", align: \"center\", }, ]; const studentRender = (params: any) =\u003e { const { record1, data1 } = params; console.log({ record1, data1 }); return ( \u003cProTable className=\"expandedTable\" scr","date":"2023-08-06","objectID":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/:0:2","tags":["React","AntD"],"title":"Antd及AntdPro组件使用积累","uri":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/"},{"categories":["前端篇"],"content":"可编辑表格 recordCreatorProps 通过设置 recordCreatorProps 属性中的 newRecordType 为 dataSource 可以取消添加数据限制 recordCreatorProps={{ newRecordType: \"dataSource\", }} ","date":"2023-08-06","objectID":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/:0:3","tags":["React","AntD"],"title":"Antd及AntdPro组件使用积累","uri":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/"},{"categories":["前端篇"],"content":"ProFormDependency 依赖某一个字段渲染另一个字段 import { ProForm, ProFormDependency, ProFormSelect } from '@ant-design/pro-components'; export default () =\u003e { const option = [{ label: '1', value: 1 }, { label: '2', value: 2 }, { label: '3', value: 3 }] return ( \u003cdiv style={{ marginTop: 200 }}\u003e \u003cProForm submitter={false}\u003e \u003cProFormSelect name=\"field1\" options={option} /\u003e \u003cProFormDependency name={['field1']}\u003e { ({ field1 }) =\u003e { if (!field1) return \u003c\u003e\u003c/\u003e const option1 = [{ label: '1-1', value: 11 }, { label: '1-2', value: 12 }, { label: '1-3', value: 13 }] const option2 = [{ label: '2-1', value: 21 }, { label: '2-2', value: 22 }, { label: '2-3', value: 23 }] const option3 = [{ label: '3-1', value: 31 }, { label: '3-2', value: 32 }, { label: '3-3', value: 33 }] return \u003cProFormSelect name=\"field2\" options={field1 === 1 ? option1 : field1 === 2 ? option2 : option3} /\u003e } } \u003c/ProFormDependency\u003e \u003c/ProForm\u003e \u003c/div\u003e ); }; ","date":"2023-08-06","objectID":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/:0:4","tags":["React","AntD"],"title":"Antd及AntdPro组件使用积累","uri":"/posts/20230806-antd%E5%8F%8Aandpro%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/"},{"categories":["前端篇"],"content":"什么是 Hook hook 即为钩子,是一种特殊的函数,它可以让你在函数式组件中使用一些 react 特性,目前在 react 中常用的 hook 有以下几类 useState: 用于在函数组件中定义和使用状态(state)。 useEffect:用于在函数组件中处理副作用,也可以模拟 react 生命周期 useContext:用于在函数组件中访问 React 的上下文(context)。 useCallback:用于在函数组件中缓存计算结果，避免无用的重复计算。 useMemo:用于在函数组件中缓存回调函数，避免无用的重渲染。 以上各种 hook 的用法在笔记文档中均有记录,如有兴趣可以前往阅览. ","date":"2023-07-02","objectID":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/:0:1","tags":["React"],"title":"React中编写操作树形数据的自定义Hook","uri":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/"},{"categories":["前端篇"],"content":"自定义 Hook 自定义 Hook 是指在 React 中编写的自定义函数，以便在各个组件之间重用逻辑。通过自定义 Hook，我们可以将一些逻辑抽象出来，使它们可以在不同的组件中共享和复用。 自定义 Hook 的命名以 “use” 开头，这是为了遵循 React 的 Hook 命名规范。自定义 Hook 可以使用任何 React 的内置 Hook，也可以组合其他自定义 Hook。 ","date":"2023-07-02","objectID":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/:0:2","tags":["React"],"title":"React中编写操作树形数据的自定义Hook","uri":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/"},{"categories":["前端篇"],"content":"编写自定义 Hook 那么如何编写自定义 hook 呢,且看以下场景: 在 Antd 中有一个 Tree 组件,现在需要对 Tree 组件的数据进行操作来方便我们在 Tree 中插入,更新,上移,下移,删除节点,此时我们就可以编写一个自定义 hook 来统一操作类似于 TreeData 这样的树形数据 我们在此将这个 hook 函数其命名为 useTreeHandler,编写这个自定义 hook 函数只需要三步同时 保存传入的数据 为传入的数据编写操作函数 将操作后的数据以及函数暴露出去供组件使用 const useTreeHandler = (TreeData: DataNode[]) =\u003e { const [gData, setGData] = useState(JSON.parse(JSON.stringify(TreeData))); return { gData, }; }; 因为本次操作的是类似 Antd 中的树形数据,就暂且使用 DataNode 类型,当然这个类型可以根据我们的需要来设定或者写一个更加通用的类型 在此 hook 函数中我们要实现以下功能 insertNodeByKey: 根据 key 来插入子级节点 insertNodeInParentByKey: 根据 key 来插入同级节点 deleteNodeByKey: 根据 key 来删除当前节点 updateTreeDataByKey: 根据 key 来更新当前节点 moveNodeInTreeByKey: 根据 key 上移/下移当前节点 插入子级 /** * 插入子级 * @param key 当前节点key * @param newNode 待插入节点 */ const insertNodeByKey = function ( key: string | number | undefined, newNode: any ) { const data = JSON.parse(JSON.stringify(gData)); const insertChild = ( data: any[], key: string | number | undefined, newNode: any ): any[] =\u003e { for (let i = 0; i \u003c data.length; i++) { if (data[i].key === key) { if (Array.isArray(data[i].children)) { data[i].children = [...data[i].children, newNode]; } else { data[i].children = [newNode]; } break; } else if (Array.isArray(data[i].children)) { insertChild(data[i].children, key, newNode); } } return data; }; setGData(insertChild(data, key, newNode)); }; 上述insertNodeByKey函数代码中传入了两个参数key 和 newNode,这两个分别代表当前操作节点对象的 key 以及插入的新节点数据,在insertNodeByKey函数内部对 gData 进行了一次深拷贝,之后在函数内操作深拷贝之后的数据,接着又定义了一个inserChild函数此函数主要进行数据操作,最后将操作后的数据重新赋值给 gData,在inserChild函数中首先对数组数据进行循环遍历,检查每一项的 key 是否和目标 key 相同,如果相同的话将新节点数据插入到当前遍历的节点的children中并break跳出循环,没有找到的话进行递归. 接下来更新节点,删除节点,上移/下移的函数和插入节点函数思路相同,在此就不一一解释,如下直接贴上代码: 插入同级 /** * 插入同级 * @param key 当前节点key 供查询父key * @param newNode 新节点数据 */ const insertNodeInParentByKey = function ( key: string | number | undefined, newNode: any ) { const data = JSON.parse(JSON.stringify(gData)); const insertBro = ( data: any[], key: string | number | undefined, newNode: any ) =\u003e { for (let i = 0; i \u003c data.length; i++) { const item = data[i]; if (item.children) { for (let j = 0; j \u003c item.children.length; j++) { const childItem = item.children[j]; if (childItem.key === key) { item.children.push(newNode); break; } else if (childItem.children) { insertBro([childItem], key, newNode); } } } } return data; }; setGData(insertBro(data, key, newNode)); }; 删除当前节点 /** * 删除当前节点 * @param data 源数据 * @param key 待删除节点key */ const deleteNodeByKey = function (key: string | number | undefined) { const data = JSON.parse(JSON.stringify(gData)); const delNode = (data: any[], key: string | number | undefined) =\u003e { for (let i = 0; i \u003c data.length; i++) { const obj = data[i]; if (obj.key === key) { data.splice(i, 1); break; } else if (obj.children) { delNode(obj.children, key); if (obj.children.length === 0) { delete obj.children; } } } }; delNode(data, key); setGData(data); }; 更新当前节点 /** * 更新子节点配置 * @param oldData 旧数据 * @param key 待更新子节点key * @param newData 更新后新数据 */ const updateTreeDataByKey = function ( key: string | number | undefined, newData: any ) { const data = JSON.parse(JSON.stringify(gData)); const updateNode = ( oldData: any[], key: string | number | undefined, newData: any[] ) =\u003e { for (let i = 0; i \u003c oldData.length; i++) { if (oldData[i].key === key) { oldData[i] = { ...oldData[i], ...newData }; break; } else { if (Array.isArray(oldData[i].children)) { updateNode(oldData[i].children, key, newData); } } } }; updateNode(data, key, newData); setGData(data); }; 当前节点上移/下移 /** * 上移/下移 * @param data 源数据 * @param key 目标key * @param direction 移动类型 * @returns 更新后数据 */ const moveNodeInTreeByKey = function ( key: string | number | undefined, direction: \"UP\" | \"DOWN\" ) { const data = JSON.parse(JSON.stringify(gData)); const moveNode = ( data: any[], key: string | number | undefined, direction: string ) =\u003e { const newData = [...data]; for (let i = 0; i \u003c newData.length; i++) { const item = newData[i]; const itemLen = item.children.length; if (item.children) { for (let j = 0; j \u003c itemLen; j++) { const ","date":"2023-07-02","objectID":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/:0:3","tags":["React"],"title":"React中编写操作树形数据的自定义Hook","uri":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/"},{"categories":["前端篇"],"content":"完整的 hook 函数 const useTreeHandler = (TreeData: DataNode[]) =\u003e { const [gData, setGData] = useState(JSON.parse(JSON.stringify(TreeData))); /** * 插入子级 * @param key 当前节点key * @param newNode 待插入节点 */ const insertNodeByKey = function ( key: string | number | undefined, newNode: any ) { const data = JSON.parse(JSON.stringify(gData)); const insertChild = ( data: any[], key: string | number | undefined, newNode: any ): any[] =\u003e { for (let i = 0; i \u003c data.length; i++) { if (data[i].key === key) { if (Array.isArray(data[i].children)) { data[i].children = [...data[i].children, newNode]; } else { data[i].children = [newNode]; } break; } else if (Array.isArray(data[i].children)) { insertChild(data[i].children, key, newNode); } } return data; }; setGData(insertChild(data, key, newNode)); }; /** * 插入同级 * @param key 当前节点key 供查询父key * @param newNode 新节点数据 */ const insertNodeInParentByKey = function ( key: string | number | undefined, newNode: any ) { const data = JSON.parse(JSON.stringify(gData)); const insertBro = ( data: any[], key: string | number | undefined, newNode: any ) =\u003e { for (let i = 0; i \u003c data.length; i++) { const item = data[i]; if (item.children) { for (let j = 0; j \u003c item.children.length; j++) { const childItem = item.children[j]; if (childItem.key === key) { item.children.push(newNode); break; } else if (childItem.children) { insertBro([childItem], key, newNode); } } } } return data; }; setGData(insertBro(data, key, newNode)); }; /** * 删除当前节点 * @param data 源数据 * @param key 待删除节点key */ const deleteNodeByKey = function (key: string | number | undefined) { const data = JSON.parse(JSON.stringify(gData)); const delNode = (data: any[], key: string | number | undefined) =\u003e { for (let i = 0; i \u003c data.length; i++) { const obj = data[i]; if (obj.key === key) { data.splice(i, 1); break; } else if (obj.children) { delNode(obj.children, key); if (obj.children.length === 0) { delete obj.children; } } } }; delNode(data, key); setGData(data); }; /** * 更新子节点配置 * @param oldData 旧数据 * @param key 待更新子节点key * @param newData 更新后新数据 */ const updateTreeDataByKey = function ( key: string | number | undefined, newData: any ) { const data = JSON.parse(JSON.stringify(gData)); const updateNode = ( oldData: any[], key: string | number | undefined, newData: any[] ) =\u003e { for (let i = 0; i \u003c oldData.length; i++) { if (oldData[i].key === key) { oldData[i] = { ...oldData[i], ...newData }; break; } else { if (Array.isArray(oldData[i].children)) { updateNode(oldData[i].children, key, newData); } } } }; updateNode(data, key, newData); setGData(data); }; /** * 上移/下移 * @param data 源数据 * @param key 目标key * @param direction 移动类型 */ const moveNodeInTreeByKey = function ( key: string | number | undefined, direction: \"UP\" | \"DOWN\" ) { const data = JSON.parse(JSON.stringify(gData)); const moveNode = ( data: any[], key: string | number | undefined, direction: string ) =\u003e { const newData = [...data]; for (let i = 0; i \u003c newData.length; i++) { const item = newData[i]; const itemLen = item.children.length; if (item.children) { for (let j = 0; j \u003c itemLen; j++) { const childItem = item.children[j]; if (childItem.key === key) { if (j === 0 \u0026\u0026 direction === \"UP\") message.info(\"已经处于第一位,无法上移\"); if (j === itemLen - 1 \u0026\u0026 direction === \"DOWN\") message.info(\"已经处于最后一位,无法下移\"); // splice (开始位置,移除元素个数,新增元素对象) if (direction === \"UP\") { item.children.splice(j, 1); item.children.splice(j - 1, 0, childItem); } else { item.children.splice(j, 1); item.children.splice(j + 1, 0, childItem); } break; } else if (childItem.children) { moveNode([childItem], key, direction); } } } } return newData; }; setGData(moveNode(data, key, direction)); }; return { gData, insertNodeByKey, insertNodeInParentByKey, deleteNodeByKey, updateTreeDataByKey, moveNodeInTreeByKey, }; }; ","date":"2023-07-02","objectID":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/:0:4","tags":["React"],"title":"React中编写操作树形数据的自定义Hook","uri":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/"},{"categories":["前端篇"],"content":"写在最后 演示地址 完整代码 ","date":"2023-07-02","objectID":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/:0:5","tags":["React"],"title":"React中编写操作树形数据的自定义Hook","uri":"/posts/20230702-react%E4%B8%AD%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89hook/"},{"categories":["前端篇"],"content":"背景 在项目中有集成低代码平台的想法,经过多方对比最后选择了 amis,主要是需要通过 amis 进行页面配置,导出 json 供移动端和 PC 端进行渲染,所以接下来讲一下近两周研究 amis 的新的以及一些简单经验,供大家参考. ","date":"2023-06-24","objectID":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/:0:1","tags":["React","Amis","低代码"],"title":"百度Amis+React实践","uri":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/"},{"categories":["前端篇"],"content":"什么是 amis amis 是一个低代码前端框架，它使用 JSON 配置来生成页面，可以减少页面开发工作量，极大提升效率。 ","date":"2023-06-24","objectID":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/:0:2","tags":["React","Amis","低代码"],"title":"百度Amis+React实践","uri":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/"},{"categories":["前端篇"],"content":"如何使用 amis 在 amis 官网提供了两种使用 amis 的方式分别是 JSSDK 可以在任意页面使用 React 可以在 React 项目中使用 博主是在 umi 框架下结合 React 使用 amis,所以本文主要着重介绍第二种方法 在使用时需要对 amis 进行安装,项目中也需要使用 amis-editor 进行页面配置所以需要同时安装如下两个包 { \"amis\": \"^3.1.1\", \"amis-editor\": \"^5.4.1\" } ","date":"2023-06-24","objectID":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/:0:3","tags":["React","Amis","低代码"],"title":"百度Amis+React实践","uri":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/"},{"categories":["前端篇"],"content":"amis 首先介绍 amis,amis 提供了 render 方法来对 amis-editor 生成的 JSON 对象页面配置进行渲染,如下,在使用是 render 主要作用就是进行渲染 import { render as renderAmis } from \"amis\"; const App = () =\u003e { return ( \u003cdiv\u003e {renderAmis({ type: \"button\", label: \"保存\", level: \"primary\", onClick: function () { console.log(\"TEST\"); }, })} \u003c/div\u003e ); }; export default App; ","date":"2023-06-24","objectID":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/:0:4","tags":["React","Amis","低代码"],"title":"百度Amis+React实践","uri":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/"},{"categories":["前端篇"],"content":"amis-editor amis-editor 提供了一个编译器组件 \u003cEditor /\u003e import { useState } from \"react\"; import { Editor, setSchemaTpl } from \"amis-editor\"; import type { SchemaObject } from \"amis\"; import { render as renderAmis } from \"amis\"; import type { Schema } from \"amis/lib/types\"; // 以下样式均生效 import \"amis/lib/themes/default.css\"; import \"amis/lib/helper.css\"; import \"amis/sdk/iconfont.css\"; import \"amis-editor-core/lib/style.css\"; import \"amis-ui/lib/themes/antd.css\"; type Props = { defaultPageConfig?: Schema; codeGenHandler?: (codeObject: Schema) =\u003e void; pageChangeHandler?: (codeObject: Schema) =\u003e void; }; export function Amis(props: Props) { const [mobile, setMobile] = useState(false); const [preview, setPreview] = useState(false); const [defaultPageConfig] = useState\u003cSchema\u003e(props.defaultPageConfig); // 传入配置 const defaultSchema: Schema | SchemaObject = defaultPageConfig || { type: \"page\", body: \"\", title: \"标题\", regions: [\"body\"], }; const [schema] = useState(defaultSchema); let pageJsonObj: Schema = defaultSchema; const onChange = (value: Schema) =\u003e { pageJsonObj = value; props.pageChangeHandler \u0026\u0026 props.pageChangeHandler(value); }; const onSave = () =\u003e { props.codeGenHandler \u0026\u0026 props.codeGenHandler(pageJsonObj); }; return ( \u003c\u003e {renderAmis({ type: \"form\", mode: \"inline\", title: \"\", body: [ { type: \"switch\", option: \"预览\", name: \"preview\", onChange: function (v: any) { setPreview(v); }, }, { type: \"switch\", option: \"移动端\", name: \"mobile\", onChange: function (v: any) { setMobile(v); }, }, { type: \"button\", label: \"保存\", level: \"primary\", onClick: function () { onSave(); }, }, { type: \"button\", label: \"退出\", level: \"danger\", onClick: function () { // if (!window.confirm('确定退出?')) return; if (props.cancleGenHandler) props.cancleGenHandler(); }, }, ], })} \u003cEditor preview={preview} isMobile={mobile} onChange={onChange} value={schema as SchemaObject} theme={\"antd\"} onSave={onSave} /\u003e \u003c/\u003e ); } export default Amis; 在 amis 中提供了两套组件样式供我们选择,分别是 cxd(云舍)和 antd(仿 Antd),我们可以通过设置Editor组件中 theme 属性来进行主题的选择,同时需要引入对应的组件样式在以上代码中,我们对Editor组件进行了二次封装,暴露出了defaultPageConfig(进入编译器默认页面 JSON 配置)属性和codeGenHandler(代码生成保存方法),cancleGenHandler(退出页面编辑器方法),pageChangeHandler(页面改变方法)供外部使用 ","date":"2023-06-24","objectID":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/:0:5","tags":["React","Amis","低代码"],"title":"百度Amis+React实践","uri":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/"},{"categories":["前端篇"],"content":"自定义组件 在 amis-editor 中使用的组件可以是我们的自定义组件.在编写自定义组件时特别需要主义的是它的 plugin 配置接下来以MyButton为例来进行自定义组件的介绍 首先来介绍以下组件结构 ├─MyButton │ ├─comp.tsx # 组件本体 │ ├─index.tsx # 整体导出 │ ├─plugin.tsx # 右侧panel配置 在comp.tsx中主要进行组件的开发 import React from \"react\"; import type { Schema } from \"amis/lib/types\"; import { Button } from \"antd\"; const MyButtonRender = React.forwardRef((props: Schema, ref: any) =\u003e { // const props = this.props return ( \u003cButton {...props} ref={ref} type={props.level || \"primary\"} name={props.name} \u003e {props.label} \u003c/Button\u003e ); }); class MyButtonRender2 extends React.Component\u003cany, any\u003e { handleClick = (nativeEvent: React.MouseEvent\u003cany\u003e) =\u003e { const { dispatchEvent, onClick } = this.props; // const params = this.getResolvedEventParams(); dispatchEvent(nativeEvent, {}); onClick?.({}); }; handleMouseEnter = (e: React.MouseEvent\u003cany\u003e) =\u003e { const { dispatchEvent } = this.props; // const params = this.getResolvedEventParams(); dispatchEvent(e, {}); }; handleMouseLeave = (e: React.MouseEvent\u003cany\u003e) =\u003e { const { dispatchEvent } = this.props; // const params = this.getResolvedEventParams(); dispatchEvent(e, {}); }; render() { return ( \u003cMyButtonRender onClick={this.handleClick} onMouseEnter={this.handleMouseEnter} onMouseLeave={this.handleMouseLeave} \u003e {this.props.label}2 \u003c/MyButtonRender\u003e ); } } export default MyButtonRender2; 在上述代码中MyButtonRender简单的对Button组件进行了简单的封装,MyButtonRender2对 amis 中组件的事件进行了简单的处理并暴露出去 在plugin.tsx中主要对MyButtonRender组件进行渲染器注册以及对组件的 plugin 进行配置,注册渲染器是为了将自定义组件拖入中间预览区域是可以正常的显示,这一操作与 amis 的工作原理有关(amis 的渲染过程是将 json 转成对应的 React 组件。先通过 json 的 type 找到对应的 Component，然后把其他属性作为 props 传递过去完成渲染。工作原理 ) 在plugin.tsx中进行 panel 配置 import { Renderer } from \"amis\"; import MyButtonRender from \"./comp\"; import type { BaseEventContext } from \"amis-editor-core\"; import { BasePlugin } from \"amis-editor-core\"; import { getSchemaTpl } from \"amis-editor-core\"; import type { RendererPluginAction, RendererPluginEvent } from \"amis-editor\"; import { getEventControlConfig } from \"amis-editor/lib/renderer/event-control/helper\"; // 渲染器注册 Renderer({ type: \"my-button\", autoVar: true, // eslint-disable-next-line @typescript-eslint/ban-ts-comment // @ts-ignore })(MyButtonRender); export class MyButton extends BasePlugin { // 关联渲染器名字 rendererName = \"my-button\"; $schema = \"/schemas/ActionSchema.json\"; order = -400; // 组件名称 name = \"MyButton\"; isBaseComponent = true; description = \"用来展示一个按钮，你可以配置不同的展示样式，配置不同的点击行为。\"; docLink = \"/amis/zh-CN/components/button\"; tags = [\"自定义\"]; icon = \"fa fa-square\"; pluginIcon = \"button-plugin\"; scaffold = { type: \"my-button\", label: \"MyButton\", wrapperBody: true, }; previewSchema: any = { type: \"my-button\", label: \"MyButton\", wrapperBody: true, }; panelTitle = \"MyButton\"; // 事件定义 events: RendererPluginEvent[] = [ { eventName: \"click\", eventLabel: \"点击\", description: \"点击时触发\", defaultShow: true, dataSchema: [ { type: \"object\", properties: { nativeEvent: { type: \"object\", title: \"鼠标事件对象\", }, }, }, ], }, { eventName: \"mouseenter\", eventLabel: \"鼠标移入\", description: \"鼠标移入时触发\", dataSchema: [ { type: \"object\", properties: { nativeEvent: { type: \"object\", title: \"鼠标事件对象\", }, }, }, ], }, { eventName: \"mouseleave\", eventLabel: \"鼠标移出\", description: \"鼠标移出时触发\", dataSchema: [ { type: \"object\", properties: { nativeEvent: { type: \"object\", title: \"鼠标事件对象\", }, }, }, ], }, ]; // 动作定义 actions: RendererPluginAction[] = []; panelJustify = true; // eslint-disable-next-line @typescript-eslint/no-unused-vars panelBodyCreator = (context: BaseEventContext) =\u003e { return getSchemaTpl(\"tabs\", [ { title: \"属性\", body: [ getSchemaTpl(\"label\", { label: \"按钮名称\", }), { type: \"input-text\", label: \"字段名称\", name: \"name\", }, { type: \"select\", label: \"按钮类型\", name: \"level\", options: [ { label: \"默认\", value: \"primary\", }, { label: \"危险\", value: \"danger\", }, { label: \"警告\", value: \"warn\", }, { label: \"成功\", value: \"success\", }, { label: \"浅色\", value: \"default\", }, ], multiple: false, selectFirst: false, }, { type: \"input-text\", label: \"按钮图标\", name: \"icon\", // 提示 labelRemark: { icon: 'icon-cl","date":"2023-06-24","objectID":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/:0:6","tags":["React","Amis","低代码"],"title":"百度Amis+React实践","uri":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/"},{"categories":["前端篇"],"content":"其他 在拖拽组件生成页面时,amis-editor 可选择的组件有很多,如果我们想使用自己组建的同时忽略隐藏原有组件可以通过disabledRendererPlugin来对原生组件进行隐藏 import { registerEditorPlugin, BasePlugin } from \"amis-editor\"; import type { RendererEventContext, SubRendererInfo, BasicSubRenderInfo, } from \"amis-editor\"; /** * 用于隐藏一些不需要的Editor组件 * 备注: 如果不知道当前Editor中有哪些预置组件，可以在这里设置一个断点，console.log 看一下 renderers。 */ // 需要在组件面板中隐藏的组件 const disabledRenderers = [ // 'flex', \"crud2\", \"crud2\", \"crud2\", // 'crud', // 'input-text', \"input-email\", \"input-password\", \"input-url\", // \"button\", \"reset\", \"submit\", \"tpl\", \"grid\", \"container\", // 'flex', // 'flex', \"collapse-group\", \"panel\", \"tabs\", // 'form', \"service\", \"textarea\", \"input-number\", // 'select', \"nested-select\", \"chained-select\", \"dropdown-button\", \"checkboxes\", \"radios\", \"checkbox\", \"input-date\", \"input-date-range\", \"input-file\", \"input-image\", \"input-excel\", \"input-tree\", \"input-tag\", \"list-select\", \"button-group-select\", \"button-toolbar\", \"picker\", \"switch\", \"input-range\", \"input-rating\", \"input-city\", \"transfer\", \"tabs-transfer\", \"input-color\", \"condition-builder\", \"fieldset\", \"combo\", \"input-group\", \"input-table\", \"matrix-checkboxes\", \"input-rich-text\", \"diff-editor\", \"editor\", \"search-box\", \"input-kv\", \"input-repeat\", \"uuid\", \"location-picker\", \"input-sub-form\", \"hidden\", \"button-group\", \"nav\", \"anchor-nav\", \"tooltip-wrapper\", \"alert\", \"wizard\", \"table-view\", \"web-component\", \"audio\", \"video\", \"custom\", \"tasks\", \"each\", \"property\", \"iframe\", \"qrcode\", \"icon\", \"link\", \"list\", \"mapping\", \"avatar\", \"card\", \"card2\", \"cards\", \"table\", \"table2\", \"chart\", \"sparkline\", \"carousel\", \"image\", \"images\", \"date\", \"time\", \"datetime\", \"tag\", \"json\", \"progress\", \"status\", \"steps\", \"timeline\", \"divider\", \"code\", \"markdown\", \"collapse\", \"log\", \"input-array\", \"control\", \"input-datetime\", \"input-datetime-range\", \"formula\", \"group\", \"input-month\", \"input-month-range\", \"input-quarter\", \"input-quarter-range\", \"static\", \"input-time\", \"input-time-range\", \"tree-select\", \"input-year\", \"input-year-range\", \"breadcrumb\", \"custom\", \"hbox\", \"page\", \"pagination\", \"plain\", \"wrapper\", \"column-toggler\", ]; export class ManagerEditorPlugin extends BasePlugin { order = 9999; buildSubRenderers( context: RendererEventContext, renderers: SubRendererInfo[] ): BasicSubRenderInfo | BasicSubRenderInfo[] | void { // 更新NPM自定义组件排序和分类 // console.log(renderers); for (let index = 0, size = renderers.length; index \u003c size; index++) { // 判断是否需要隐藏 Editor预置组件 const pluginRendererName = renderers[index].rendererName; if ( pluginRendererName \u0026\u0026 disabledRenderers.indexOf(pluginRendererName) \u003e -1 ) { renderers[index].disabledRendererPlugin = true; // 更新状态 } } } } registerEditorPlugin(ManagerEditorPlugin); ","date":"2023-06-24","objectID":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/:0:7","tags":["React","Amis","低代码"],"title":"百度Amis+React实践","uri":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/"},{"categories":["前端篇"],"content":"写在最后 一个阶段的结束伴随着另一个阶段的开始,在新的阶段中会继续学习继续进步,如文章有问题通过页脚邮箱进行联系 ","date":"2023-06-24","objectID":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/:0:8","tags":["React","Amis","低代码"],"title":"百度Amis+React实践","uri":"/posts/20230624-%E7%99%BE%E5%BA%A6amis+react%E5%AE%9E%E8%B7%B5/"},{"categories":["前端篇"],"content":"一:函数 在 React 中我们通常使用 tsx 来编写代码,在编码时我经常会遇到一个,选择用什么方式来调用我们的函数如: const clickMe=()=\u003e{ console.log('button') } \u003cbutton onClick={clickMe}\u003eclickMe\u003c/button\u003e // 1 \u003cbutton onClick={clickMe()}\u003eclickMe\u003c/button\u003e // 2 \u003cbutton onClick={()=\u003eclickMe()}\u003eclickMe\u003c/button\u003e // 3 当我们使用第一种方法来调用函数时,这个函数就像传递的任何其他函数一样调用,直接调用即可 在第二种方式中,这个函数不只是传递了打印操作功能,此时需要有一个返回的函数 在第三种方式中,就是一个基本的函数调用,如果不需要返回值的话,无需关心返回的内容 ","date":"2023-05-07","objectID":"/posts/20230507-react%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/:0:1","tags":["React","踩坑记录"],"title":"React使用中常犯的错误","uri":"/posts/20230507-react%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/"},{"categories":["前端篇"],"content":"二:短路 在 React 中我们经常需要通过一个或多个属性来判断一些元素是否需要被渲染如下,当数组不为空时渲染按钮 export default (props: Props) =\u003e { const array = [1, 2, 3]; return ( \u003cdiv\u003e {array.length \u0026\u0026 array.map((item) =\u003e { return \u003cButton\u003e按钮-{item}\u003c/Button\u003e; })} \u003c/div\u003e ); }; 值得注意的是当array.length不为 0 时,代码会是偶们想要的效果,当array为空时,array.length为 0,此时 React 会将 0 渲染到页面上,而null,undefined,false则不会出现这个问题,所以当需要判断数组长度时,需要准确判断array.length===0orarray.length!==0,由于[]和{}隐式转换为true,所以当判断对象时也需要准确判断是否为null ","date":"2023-05-07","objectID":"/posts/20230507-react%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/:0:2","tags":["React","踩坑记录"],"title":"React使用中常犯的错误","uri":"/posts/20230507-react%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/"},{"categories":["前端篇"],"content":"在项目中使用使用进度条时遇到了一点问题,根据需求进度条的百分比需要在条内显示,但是当完成度太低时由于进度条背景和百分比值都是接近的颜色,所以此时无法显示进度值,这个时候需要根据完成度大小来进行判断,动态给进度值设置颜色. 先将实现后的效果图展示出来 如上图所示 ,第一幅图几乎看不出来进度值,此时我们稍作改变 // index.tsx 改变前进度条 // proportion 状态值,通过判断状态来改变进度条 \u003cp className={styles.rate}\u003e \u003cProgress strokeLinecap=\"butt\" strokeWidth={16} percent={proportion} /\u003e \u003c/p\u003e // index.tsx 改变后进度条 // proportion 状态值,通过判断状态来改变进度条 \u003cp className={styles.rate}\u003e \u003cProgress strokeLinecap=\"butt\" style={ proportion \u003e 5 ? { color: \"var(--progress-text-col, white)\" } : { color: \"var(--progress-text-col, black)\" } } strokeWidth={16} percent={proportion} /\u003e \u003c/p\u003e 在less中 /* :global 用来覆盖默认样式 */ .rate { width: 300px; \u0026 :global(.ant-progress-inner) { padding: 0; } \u0026 :global(.ant-progress-text) { position: absolute; color: var(--progress-text-col); font-size: 12px; } } 接下来介绍一下var在css中的作用 var()是一个css函数,可以插入一个自定义属性,这个自定义属性我们可以在全局复用 var()支持我们传入两个参数,第一个参数是要替换的自定义属性名,第二个参数是可选的,用作回退值,当一个参数无效时,就会使用第二个参数,我们可以利用这一点来给某一个样式的设置值. 当我们的第二个参数是一个时,可以看作给第一个参数赋值,因为第一个参数不起作用就会回退到第二个参数,在上述的less代码中,因为没有在其他位置定义--progress-text-col,所以--progress-text-col这个参数无效回退到white或者black,此时color就是white或者black. 值得注意的是,以上述情景为例,当在其他位置定义了--progress-text-col,此时在less中--progress-text-col就会生效,index.tsx内的color赋值操作就会不起作用 ","date":"2023-04-21","objectID":"/posts/20230421-%E5%9C%A8js%E4%B8%AD%E4%BF%AE%E6%94%B9less%E6%96%87%E4%BB%B6%E5%86%85%E6%A0%B7%E5%BC%8F/:0:0","tags":["React","less","JavaScript"],"title":"在js中修改less文件内样式","uri":"/posts/20230421-%E5%9C%A8js%E4%B8%AD%E4%BF%AE%E6%94%B9less%E6%96%87%E4%BB%B6%E5%86%85%E6%A0%B7%E5%BC%8F/"},{"categories":["前端篇"],"content":"最近在工作中接触到了 antd 和 antd pro,作为一个 react 和 antd 新人,在学习和使用中遇到了不少的问题,下边就常见的一个问题来进行记录,后续还会记录更多的问题以及心得 Form 以及 ProForm 组件在项目中是最常用的组件,Antd 中表单相关组件常用的两个 props 是 fieldProps 和 formItemProps。在做项目配置 columns 时,因为不熟悉时常被这两个 props 搞得很烦,接下来详细解释一下这两个东西 在介绍这两个 Props 之前需要先了解以下Form.Item 在 Form 中 Form.Item 用于封装表单项组件,用于渲染表单控件和对应的标签,错误信息等内容,通常被嵌套在 Form 组件中使用,简单使用如下: ... const verifyPassword = (rule, value) =\u003e { let passwordReg = /^(?![a-zA-Z]+$)(?!\\d+$)(?![^\\da-zA-Z\\s]+$){1,9}$/; const flag = passwordReg.test(value); if (flag) { return Promise.resolve(); } else { return Promise.reject(new Error(\"密码需由字母、数字、特殊符，任意2种组成，1-9位\")); } }; const verifyEmail = (rule, value) =\u003e { let emailReg = /^([a-zA-Z\\d][\\w-]{2,})@(\\w{2,})\\.([a-z]{2,})(\\.[a-z]{2,})$/; const flag = emailReg.test(value); console.log(flag); if (flag) { return Promise.resolve(); } else { return Promise.reject(new Error(\"邮箱格式不正确\")); } }; ... \u003cForm name=\"basic\" labelCol={{ span: 8, }} wrapperCol={{ span: 16, }} autoComplete=\"off\" \u003e \u003cForm.Item label=\"Email\" name=\"email\" rules={[ { required: true, message: \"Please input your username!\", }, { validator: verifyEmail }, ]} \u003e \u003cInput /\u003e \u003c/Form.Item\u003e \u003cForm.Item label=\"Password\" name=\"password\" rules={[ { required: true, message: \"Please input your password!\", }, { validator: verifyPassword }, ]} \u003e \u003cInput.Password /\u003e \u003c/Form.Item\u003e \u003c/Form\u003e 如上述代码,我们可以在 Form.Item 中进行规则校验,渲染\u003cInput /\u003e标签,当然可以渲染的不仅仅有Input还有一些其他的表单组件 接下来我们看 ProForm 组件,ProForm 在原来的 Form 的基础上增加一些语法糖和更多的布局设置，帮助我们快速的开发一个表单。同时添加一些默认行为，让我们的表单更加好用。 以 ProFormDigit 为例,ProFormDigit 是在 inputNumber 中的基础上进行了二次封装,我们可以直接在 ProFormDigit 上通过 fieldProps 向 inputNumber 组件上进行属性透传,这个属性也可以是类似于 onBlur 之类的事件 \u003cProFormDigit label=\"总量\" name=\"totalCount\" readonly={detailState} initialValue={0} rules={[ { required: true, message: \"该字段必填\", }, ]} placeholder=\"请输入\" colProps={{ span: 12 }} fieldProps={{ onBlur: async (e) =\u003e { if (e) { console.log(e); } }, precision: 2, }} /\u003e fieldProps 和 formItemProps 在 ProTable 中也经常使用,我们通常在 colums 中进行配置,而且在配置时我们可以使用函数的形式,在函数中进行一些验证之类,值得注意的是如果我们还需要透传其他属性,需要返回一个对象来包裹这些属性,示例如下 const columns=[ ..., { title: '总量', dataIndex: 'totalCount', key: 'totalCount', width: 150, align: 'center', fixed: 'left', valueType: 'digit', formItemProps: { rules: [{ required: true, message: '此字段必填' }], }, fieldProps: (form, config: any) =\u003e { // 金额校验 const flag = valid(config.entry); if (!flag) { return { addonBefore: ( // 在输入框前渲染提示组件 \u003cTooltip title=\"金额校验\"\u003e \u003cExclamationCircleOutlined style={{ color: 'red' }} /\u003e \u003c/Tooltip\u003e ), }; } return { precision: 2, }; }, ... ] 简单来说 fieldProps 用于设置在 FormItem 组件内部渲染的表单字段组件（如 Input、Select 等）的 props。 它是一个对象，接受字段组件的各种 props，例如 value、onChange、disabled、placeholder 等。fieldProps 向下传递到底层表单字段组件，用于控制其行为和外观。 formItemProps 用于设置 FormItem 组件本身的道具。 它是一个对象，它接受 FormItem 组件的各种属性，例如标签、名称、规则、冒号等。formItemProps 用于控制 FormItem 组件的布局和行为，例如其标签、验证规则等。 本篇到此结束 ","date":"2023-04-13","objectID":"/posts/20230413-antdpro%E4%B8%ADformitemprops%E5%92%8Cfieldprops%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["React","Ant Design"],"title":"Antd Pro中formItemProps和fieldProps的区别","uri":"/posts/20230413-antdpro%E4%B8%ADformitemprops%E5%92%8Cfieldprops%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["工具篇"],"content":"通过使用这个插件我们可以很方便的进行组件/方法/文件的导入 本篇博客仅对插件进行介绍翻译,便于自己以后使用 常用片段列表 imr: 引入 React import React from 'react' imrc: 导入 React 组件 import React, { Component } from 'react' imrn: 导入 Import React-Native Element import { first } from 'react-native' cdm: 快速生成类组件中 componentWillMount 函数componentWillMount() {} cdup: 快速生成类组件中 componentDidUpdate 函数componentDidUpdate(prevProps, prevState) {} cwm: 快速生成类组件中 componentWillMont 函数componentWillMount() {} cwup: 快速生成类组件中 componentWillUpdate 函数componentWillUpdate(nextProps, nextState) {} rcc: 快捷生成类组件 import React, { Component } from \"react\"; export default class test extends Component { render() { return ( res: 快捷生成函数组件 import React from \"react\"; const test = () =\u003e { return \u003cdiv\u003e\u003c/div\u003e; }; export default test; fcc: 快捷生成类组件(附带类型声明) import * as React from \"react\"; type Props = {}; type State = {}; export class test extends React.Component\u003cProps, State\u003e { render() { return \u003cdiv\u003e\u003c/div\u003e; } } fsc: 快捷生成函数组件(箭头函数类型) import * as React from \"react\"; type Props = {}; export const test = (props: Props) =\u003e { return \u003cdiv\u003e\u003c/div\u003e; }; cmmb: 生成大块注释 /** * first */ ednf: 生成默认导出函数export default function first(second) {third} edf: 生成默认导出函数export default (first) =\u003e {second} 类似的快捷方式还是有很多,在这里仅记录常用的,如需更多请去往React-Native/React/Redux snippets for es6/es7 version Standard ","date":"2023-04-07","objectID":"/posts/20230407-vscode%E4%B8%ADreact%E7%BB%84%E4%BB%B6/:0:0","tags":["Vscode","插件"],"title":"vscode中ES7+ React/Redux/React-Native snippets插件使用","uri":"/posts/20230407-vscode%E4%B8%ADreact%E7%BB%84%E4%BB%B6/"},{"categories":["前端篇"],"content":"开头先把错误贴上 src/hooks/usePageSearch.ts:9:27 TS2339: Property 'getPageData' does not exist on type '{ $:ComponentInternalInstance; $data: {}; $props: Partial\u003c{}\u003e \u0026 Pick\u003cReadonly\u003cExtractPropTypes\u003c{}\u003e\u003e \u0026 VNodeProps \u0026AllowedComponentProps \u0026 ComponentCustomProps, \"key\" | ... 10 more ... | \"style\"\u003e; ... 10 more ...; $watch(source: string | Function, cb:Function, options?: WatchOptions\u003c...\u003e | undefined): WatchStopHan...'. \u003e 9 | pageContentRef.value?.getPageData({}) 在这里解释一下错误,错误的原因是将导入的组件转换为类型后组件中没有对应的getPageData类型 经过测试这个错误只在vue-cli中出现,在新版本的vite中没有出现 解决办法是将getPageData的类型进行定义然后对导入的pageContent类型使用extends进行继承,具体代码如下 import { ref } from \"vue\"; import PageContent from \"@/components/page-content\"; interface INewPageContent extends InstanceType\u003ctypeof PageContent\u003e { getPageData(): void; } const pageContentRef = ref\u003cINewPageContent\u003e(); pageContentRef.value?.getPageData(); 组件中 \u003cscript setup lang=\"ts\"\u003e const getpageData=(){ console.log('get the data here') } defineExpose({ getPageData }) \u003c/script\u003e 关于 extends 类型继承可以参考以下代码 interface Animal { eat: boolean; } interface Bird extends Animal { fly: boolean; } interface Fish extends Animal { swim: boolean; } let bird = \u003cBird\u003e{}; bird.eat = true; bird.fly = true; // bird.swim --\u003e error: Property 'swim' does not exist on type 'Bird' 至此问题解决 🎉 ","date":"2022-12-29","objectID":"/posts/20221229-vue3%E4%B8%AD%E4%BD%BF%E7%94%A8defineexpose%E6%8A%A5ts-2339/:0:0","tags":["Vue","踩坑记录"],"title":"vue3+ts使用defineExpose报TS:2339","uri":"/posts/20221229-vue3%E4%B8%AD%E4%BD%BF%E7%94%A8defineexpose%E6%8A%A5ts-2339/"},{"categories":["前端篇"],"content":"最近在写项目时遇到了一个问题,当我从父组件向子组件传数据并且需要将子组件对传入的数据进行v-for循环渲染时,在此出遇到了一个ts报错 报错为循环出的data类型为unknown 具体代码如下 : 子组件(修改前) : \u003c!-- child --\u003e \u003ctemplate\u003e \u003cdiv class=\"child\"\u003e \u003cdiv v-for=\"data in dataList\" :key=\"data.id\"\u003e {{ data.name }} \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { defineComponent } from 'vue' export default defineComponent({ props: { dataList: { type: Array, required: true } }, setup() { return {} } }) \u003c/script\u003e 父组件 : \u003c!-- parent --\u003e \u003ctemplate\u003e \u003cchild :dataList=\"dataList\"\u003e\u003c/child\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { defineComponent } from 'vue' import child from './child.vue' import { IData } from './types' export default defineComponent({ components: { child }, setup() { const dataList: IData[] = [ { id: 0, name: 'zs', age: 18 }, { id: 1, name: 'ls', age: 19 }, { id: 2, name: 'ww', age: 20 } ] return { dataList } } }) \u003c/script\u003e \u003cstyle scoped lang=\"less\"\u003e\u003c/style\u003e 类型声明 : // types export interface IData { id: number name: string age: number } 解决办法使用props的时候使用PropType将数据类型完整标注即可 PropType:用于在用运行时 props 声明时给一个 prop 标注更复杂的类型定义。 更多PropType详情可见 : https://cn.vuejs.org/api/utility-types.html#typing-component-props 解决后的代码 子组件(修改后) : ... \u003cscript lang=\"ts\"\u003e import { defineComponent, PropType } from 'vue' import { IData } from './types' export default defineComponent({ props: { dataList: { // 修改位置在此 type: Array as PropType\u003cIData[]\u003e, required: true } }, setup() { return {} } }) \u003c/script\u003e ... 此时问题已修复并且data可以进行类型推导 至此问题解决 🎉 ","date":"2022-12-27","objectID":"/posts/20221227-vue3+ts%E4%BD%BF%E7%94%A8v-for%E5%87%BA%E7%8E%B0unknown%E9%97%AE%E9%A2%98/:0:0","tags":["Vue","踩坑记录"],"title":"vue3+ts使用v-for出现unknown问题","uri":"/posts/20221227-vue3+ts%E4%BD%BF%E7%94%A8v-for%E5%87%BA%E7%8E%B0unknown%E9%97%AE%E9%A2%98/"},{"categories":["前端篇"],"content":"修改网页中侧边滚动条可以对如下几方面进行修改 ::-webkit-scrollbar:滚动条整体 ::-webkit-scrollbar-thumb:可拖拽区域 ::-webkit-scrollbar-track:滚动条轨道 ::-webkit-scrollbar-button:滚动条两端 ::-webkit-scrollbar-corner:垂直水平滚动条交汇部分 ","date":"2022-12-21","objectID":"/posts/20221221-%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/:0:1","tags":["Css"],"title":"网页滚动条样式修改","uri":"/posts/20221221-%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/"},{"categories":["前端篇"],"content":"具体兼容可参考 https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-scrollbar ","date":"2022-12-21","objectID":"/posts/20221221-%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/:0:2","tags":["Css"],"title":"网页滚动条样式修改","uri":"/posts/20221221-%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/"},{"categories":["前端篇"],"content":"示例 效果图请前往 https://exampleliil.pages.dev/blog/20221221 ","date":"2022-12-21","objectID":"/posts/20221221-%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/:0:3","tags":["Css"],"title":"网页滚动条样式修改","uri":"/posts/20221221-%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/"},{"categories":["前端篇"],"content":"File ","date":"2022-12-16","objectID":"/posts/20221216-fileapi%E4%B8%8Eblobapi/:1:0","tags":["JavaScript"],"title":"FileAPI与BlobAPI","uri":"/posts/20221216-fileapi%E4%B8%8Eblobapi/"},{"categories":["前端篇"],"content":"简单介绍 HTML5在DOM上为文件输入元素添加了Files集合,当用户在文件字段中选择一个或多个文件时,这个files及合作中会包含一组File对象,表示被选中的文件,File对象是一种特殊的Blob对象 ","date":"2022-12-16","objectID":"/posts/20221216-fileapi%E4%B8%8Eblobapi/:1:1","tags":["JavaScript"],"title":"FileAPI与BlobAPI","uri":"/posts/20221216-fileapi%E4%B8%8Eblobapi/"},{"categories":["前端篇"],"content":"创建 input元素选择文件后返回的FileList对象 文件拖放操作生成的DataTransfer对象,event.dataTransfer.files ","date":"2022-12-16","objectID":"/posts/20221216-fileapi%E4%B8%8Eblobapi/:1:2","tags":["JavaScript"],"title":"FileAPI与BlobAPI","uri":"/posts/20221216-fileapi%E4%B8%8Eblobapi/"},{"categories":["前端篇"],"content":"Blob ","date":"2022-12-16","objectID":"/posts/20221216-fileapi%E4%B8%8Eblobapi/:2:0","tags":["JavaScript"],"title":"FileAPI与BlobAPI","uri":"/posts/20221216-fileapi%E4%B8%8Eblobapi/"},{"categories":["前端篇"],"content":"简单介绍 blob 表示二进制大对象(binary larget object),是 javascript 对不可修改二进制数据的封装类型.包含字符串数组,ArrayBuffers,ArrafBufferViews,甚至其他的 Blob 都可以来创建 blob.blob 对象不可修改,从 blob 中读取内容的唯一方法是使用 FileReader ","date":"2022-12-16","objectID":"/posts/20221216-fileapi%E4%B8%8Eblobapi/:2:1","tags":["JavaScript"],"title":"FileAPI与BlobAPI","uri":"/posts/20221216-fileapi%E4%B8%8Eblobapi/"},{"categories":["前端篇"],"content":"创建 let blob=new Blob(array,options) 返回一个新创建的 Blob 对象，其内容由参数中给定的数组拼接组成。 array:由 ArrayBuffer,ArrayBufferView,Blob,DOMString 等对象构成 options:可以在此指定 MIME 类型 MIME 类型:媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型）是一种标准，用来表示文档、文件或字节流的性质和格式。它在 IETF RFC 6838 中进行了定义和标准化。 let blob = new Blob([\"hello Blob\"], { type: \"text/plain\" }); console.log(blob); // Blob {size: 10, type: 'text/plain'} ","date":"2022-12-16","objectID":"/posts/20221216-fileapi%E4%B8%8Eblobapi/:2:2","tags":["JavaScript"],"title":"FileAPI与BlobAPI","uri":"/posts/20221216-fileapi%E4%B8%8Eblobapi/"},{"categories":["前端篇"],"content":"读取 使用 FileReader 来进行 blob 对象的读取,也可以使用 Blob.prototype.text()来读取字符串格式的 blob 对象 FileReader:D Blob.prototype.text(): ","date":"2022-12-16","objectID":"/posts/20221216-fileapi%E4%B8%8Eblobapi/:2:3","tags":["JavaScript"],"title":"FileAPI与BlobAPI","uri":"/posts/20221216-fileapi%E4%B8%8Eblobapi/"},{"categories":["前端篇"],"content":"属性方法 属性 size:Blob 对象中所包含数据的大小(字节) type:Blob 对象的 MIME 类型,如类型为止则为空字符串 方法 Blob.prototype.arrayBuffer():返回一个 promise，其会兑现一个包含 Blob 所有内容的二进制格式的 ArrayBuffer。 Blob.prototype.slice(start,end,contentType):返回一个新的 Blob 对象,可以对原来对象进行复制 start:切片起点,默认为 0 end:切片重点,默认为 blob.size 设置新的 blob 的,MIME 类型,默认为 blob 原始值 Blob.prototype.stream():返回一个能读取 Blob 内容的 ReadableStream。 Blob.prototype.text():返回一个 promise，其会兑现一个包含 Blob 所有内容的 UTF-8 格式的字符串。 ","date":"2022-12-16","objectID":"/posts/20221216-fileapi%E4%B8%8Eblobapi/:2:4","tags":["JavaScript"],"title":"FileAPI与BlobAPI","uri":"/posts/20221216-fileapi%E4%B8%8Eblobapi/"},{"categories":["前端篇"],"content":"在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。 柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数” 函数柯里化可以让我们在不同的环境使用相同的调用方法 参数的复用 函数柯里化最简单的应用就是参数的复用,可以简化后续调用 function uri(protocol, hostname, pathname) { return function (hostname, pathname) { return `${hostname}${pathname}`; }; } let uri_https = uri(\"https://\"); let uri2 = uri_https(\"plumliil.eu.org\", \"/tags\"); let uri3 = uri_https(\"plumliil.eu.org\", \"/about\"); console.log(uri2, uri3); 在上方代码中第一次使用 uri 函数来获得了一个新的函数 uri_https,此时通过闭包可以将 protocol 保存下来供后续函数使用,在接下来的代码中通过调用新函数uri_https来获得最终的返回结果,此过程实现了https://参数的复用 兼容性的检测 通过函数柯里化可以检查代码是否在ie浏览器或者主流浏览器中运行如 // 立即执行函数,只需触发一次if判断 const watchEvent = (function () { if (window.addEventListener) { return function (element, type, listener, useCapture) { element.addEventListener(type, function (e) { listener.call(element, e) }, useCapture) } } else if (window.attachEvent) { return function (element, type, handler) { element.attachEvent('on' + type, function (e) { handler.call(element, e) }) } } })(); 延迟执行 function add() { let args = [...arguments]; let inner = function () { args.push(...arguments) return inner } inner.toString = function () { return args.reduce((pre, cur, index) =\u003e { return pre + cur }, 0) } return inner; } let res = add(1)(2)(3)(4); console.log(res); // console.log(typeof res); // function ","date":"2022-12-06","objectID":"/posts/20221206-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/:0:0","tags":["JavaScript"],"title":"函数柯里化","uri":"/posts/20221206-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"},{"categories":["计网篇"],"content":"如果将网络体系按照OSI模型划分可分为7层: 1:物理层 2:数据链路层 3:网络层 4:传输层 5:会话层 6:表示层 7:应用层 其中传输层起到呈上启下作用,建立端到端的连接, 客户端和服务端都有各自IP地址,以B站为例,同一个IP地址使用Firefox和Chrome向服务器发送请求,此时端口号可以保证服务器不会错发给不同的应用进程. 套接字socket:IP地址:端口号 三次握手:(SYN:同步,ACK:确认) 客户端(序号:9527)——SYN——\u003e服务端(序号:100) 服务端(确认号:9527+1)—-SYN+ACK—-\u003e客户端(序号:9527+1) 客户端(序号:9527+1,确认号:100+1)——ACK——\u003e服务端 握手之后建立连接:(ACK:确认,FIN:结束) 客户端(序号:🐕,确认号:💩)—-FIN+ACK—-\u003e服务端(序号:💩,确认号:🐕+1) 服务端(序号:💩,确认号:🐕+1)——ACK——\u003e客户端(序号:💩,确认号:🐕+1) 服务端(序号:💩,确认号:🐕+1)——FIN+ACK——\u003e客户端(序号:💩,确认号:🐕+1) 客户端(序号:🐕+1,确认号:💩+1)——ACK——\u003e 客户端:我要关闭连接了 服务端:收到 服务端:那我也要关闭连接了 客户端:好的 ","date":"2022-11-28","objectID":"/posts/20221113-tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:0","tags":["网络基础"],"title":"tcp三次握手和四次挥手","uri":"/posts/20221113-tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["前端篇"],"content":" async,await 是基于 promise,async 函数始终返回一个 Promise 对象 await 的意思是等待,函数等待 await 执行之后才继续往下执行 async 和 await 的其中一个作用就是可以优化 Fetch 语法 使用 generator 来实现 async,await 数据获取 function getData(arg) { return new Promise((resolve) =\u003e { let rdm = Math.floor(Math.random() * (1000 - 100) + 100); setTimeout(() =\u003e { resolve(arg); }, rdm); }); } 语法糖 async function aFn() { const data1 = await getData(1); const data2 = await getData(data1); return `success,${data2}`; } aFn().then((res) =\u003e console.log(res)); 迭代器 function* fn() { const data1 = yield getData(1); console.log(data1); const data2 = yield getData(data1); console.log(data2); return `success,${data2}`; } function generatorToAsync(genFn) { return function () { const gen = genFn.apply(this, arguments); return new Promise((resolve, reject) =\u003e { function step(key, arg) { let res; try { res = gen[key](arg); } catch (error) { return reject(error); } const { value, done } = res; if (done) { return resolve(value); } else { return Promise.resolve(value).then( (val) =\u003e step(\"next\", val), (err) =\u003e step(\"throw\", err) ); } } step(\"next\"); }); }; } const asyncFn = generatorToAsync(fn); asyncFn().then((res) =\u003e console.log(res)); ","date":"2022-11-27","objectID":"/posts/20221127-async%E5%92%8Cawait/:0:0","tags":["JavaScript"],"title":"async和await","uri":"/posts/20221127-async%E5%92%8Cawait/"},{"categories":["前端篇"],"content":"使用ts简单封装localStorage函数,使之具有时效性 class MyLocalStorage { private static time: number = new Date().getTime(); private constructor() {} public static get(key: string) { let value = localStorage.getItem(key); if (!value) return null; let valueArr = value.split(\"|\"); // 如果和储存字符冲突可以另换其它字符 if (valueArr.length \u0026\u0026 valueArr.length \u003e 1) { if (this.time \u003e parseInt(valueArr[1])) { localStorage.removeItem(key); console.log(this.time, parseInt(valueArr[1])); return \"\"; } else { return JSON.parse(valueArr[0]); } } else { return JSON.parse(value); } } public static set(key: string, value: any) { localStorage.setItem(key, JSON.stringify(value)); } public static cacheSet( key: string, value: any, delay: number = 1000 * 60 * 3600 ) { value = JSON.stringify(value) + \"|\" + (this.time + delay); localStorage.setItem(key, value); } public static remove(key: string) { localStorage.removeItem(key); return \"\"; } } 思路很简单,存入数据时将时间也一并存入添加到数据中并用特殊符号分割,当取出时和缓存时间对比,判断是否需要去除或者移除. ","date":"2022-11-01","objectID":"/posts/20221101-%E8%AE%BE%E7%BD%AElocalstorage%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/:0:0","tags":["TypeScript"],"title":"localStorage数据过期时间的设置","uri":"/posts/20221101-%E8%AE%BE%E7%BD%AElocalstorage%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/"},{"categories":["前端篇"],"content":"vue2响应式 vue2响应式的核心是通过defineProperty来对对象已有的属性值的读取和修改进行劫持(监视/拦截) ","date":"2022-10-26","objectID":"/posts/20221026-vue2%E5%92%8Cvue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%BA%E5%88%AB/:1:0","tags":["Vue"],"title":"vue2和vue3的响应式区别","uri":"/posts/20221026-vue2%E5%92%8Cvue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%BA%E5%88%AB/"},{"categories":["前端篇"],"content":"对象的响应式实现 // 简单实现 // 假设app为vue实例 const app = {} const data = { name: 'zs', age: 18 } // 遍历data,将data属性绑定到app上,对属性的读取和修改进行拦截 Object.entries(data).forEach(([prop, value]) =\u003e { let initValue = value; Object.defineProperty(app, prop, { get() { console.log('defineProperty内部监视 执行get') return initValue }, set(newValue) { console.log('defineProperty内部监视 执行set'); initValue = newValue } }) }) console.log(app.name); // defineProperty内部监视 执行get zs app.name = 'ls'; // defineProperty内部监视 执行set app.sex = '男'; // 不会执行set方法 console.log(app.sex); // 不会执行get方法 ","date":"2022-10-26","objectID":"/posts/20221026-vue2%E5%92%8Cvue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%BA%E5%88%AB/:1:1","tags":["Vue"],"title":"vue2和vue3的响应式区别","uri":"/posts/20221026-vue2%E5%92%8Cvue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%BA%E5%88%AB/"},{"categories":["前端篇"],"content":"数组的响应式实现 通过重写数组的一系列更新元素方法来实现元素的修改劫持 // 简单实现 const obj = { push() {}, pop() {}, shift() {}, unshift() {}, splice() {}, sort() {}, reverse() {} } Object.keys(obj).forEach(key =\u003e { Object.defineProperty(obj, key, { value(...args) { console.log('args', args); return Array.prototype[key].call(this, ...args) } }) }) const arr = []; arr.__proto__ = obj; arr.push(1, 2); // args[1,2] console.log(arr[0]); // 1 我们知道arr.__proto__等于它的构造函数的原型,也就是Array.prototype,所以arr可以执行push,pop等方法,但是现在arr.__proto__指向obj,所以arr.push相当于obj.push用defineProperty进行监听,obj.push()就会执行value函数,通过call方法进行数组操作 ","date":"2022-10-26","objectID":"/posts/20221026-vue2%E5%92%8Cvue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%BA%E5%88%AB/:1:2","tags":["Vue"],"title":"vue2和vue3的响应式区别","uri":"/posts/20221026-vue2%E5%92%8Cvue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%BA%E5%88%AB/"},{"categories":["前端篇"],"content":"vue3响应式 通过Proxy来拦截对对象本身的操作,包括属性的读写,属性的添加,属性的删除等… 通过Reflect来动态对被代理的对象的相应属性进行特定操作 // 简单实现: const user = { name: 'zs', age: 18 } const proxy = new Proxy(user, { get(target, prop) { console.log('劫持get操作', prop) return Reflect.get(target, prop) }, set(target, prop, val) { console.log('劫持set()', prop, val); return Reflect.set(target, prop, val) }, deleteProperty(target, prop) { console.log('劫持delete', prop); return Reflect.deleteProperty(target, prop) }, }) // 读取属性值 console.log(proxy === user); console.log(proxy.name); // 劫持get() name zs // 设置属性值 proxy.name = 'ls'; // 劫持set() name ls proxy.age = 19; // 劫持set() age 19 console.log(user); // { name: 'ls', age: 19 } // 添加属性 proxy.sex = '男'; // 劫持set() sex 男 console.log(user); //{ name: 'ls', age: 19, sex: '男' } // 删除属性 delete proxy.sex; // 劫持delete sex console.log(user); // { name: 'ls', age: 19 } 总结:正是由于vue3使用proxy代理的方式拦截对象本身,所以在vue3中添加/删除属性都是响应式的,通过下标修改数组也是响应式 ","date":"2022-10-26","objectID":"/posts/20221026-vue2%E5%92%8Cvue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%BA%E5%88%AB/:2:0","tags":["Vue"],"title":"vue2和vue3的响应式区别","uri":"/posts/20221026-vue2%E5%92%8Cvue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%BA%E5%88%AB/"},{"categories":["版本管理"],"content":" 今天在提交时遇到了两个报错，是第一个报错解决后紧接着出现了第二个报错 git fatal: index file smaller than expected fatal: cannot lock ref 'HEAD': unable to resolve reference 'refs/heads/main': reference broken 第一个报错的原因是git文件夹中的index文件出错，解决办法是删除该index文件，然后运行git reset重新进行生成，但是git reset后提交是能提交了，但是不能push到远程仓库于是就出现了第二个问题。 第二个报错可能是因为我删除了git中的index文件,导致.git文件损坏，解决办法，重新将远程仓库的.git文件夹复制到当前项目文件夹并覆盖，但是此举需要重新提交代码. ","date":"2022-07-28","objectID":"/posts/20220728-git%E6%8A%A5%E9%94%99%E9%94%99%E8%AF%AF%E4%BE%9D%E6%AC%A1%E5%87%BA%E7%8E%B0/:0:0","tags":["Git","踩坑记录"],"title":"git报错(错误依次出现)","uri":"/posts/20220728-git%E6%8A%A5%E9%94%99%E9%94%99%E8%AF%AF%E4%BE%9D%E6%AC%A1%E5%87%BA%E7%8E%B0/"},{"categories":["前端篇"],"content":"继承 在javacript继承很是重要,通过继承可以实现代码的复用,让子类继承父类从而减少代码量,记下来使用多个方法来实现继承. ","date":"2022-07-22","objectID":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/:1:0","tags":["JavaScript"],"title":"javascript中继承的几种实现方法","uri":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"},{"categories":["前端篇"],"content":"1.原型链的继承 原型链继承存在的问题: 原型中包含的引用类型属性将被所有实例共享,某一个实例改变属性其他的实例属性也会跟着改变 子类在实例化的时候不能给父类构造函数传参 function Animal() { this.color = ['yellow', 'black']; } Animal.prototype.getColor = function () { console.log(this.color) } function Dog() { } Dog.prototype = new Animal(); let dog = new Dog(); dog.getColor(); // [\"yellow\",\"black\"] dog.color.push('white'); let dog2 = new Dog(); dog2.getColor(); // [\"yellow\",\"black\",\"white\"] ","date":"2022-07-22","objectID":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/:1:1","tags":["JavaScript"],"title":"javascript中继承的几种实现方法","uri":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"},{"categories":["前端篇"],"content":"2.借用构造函数实现继承 借用构造函数继承解决了原型链继承的2个问题：引用类型共享问题以及传参问题。但是由于方法定义在构造函数中，所以会导致创建子类实例都会创建一遍方法 function Animal(name) { this.name = name; this.getName = function () { console.log(this.name); } } function Cat(name) { Animal.call(this, name) } Cat.prototype = new Animal(); let cat = new Cat('cat'); cat.getName() ","date":"2022-07-22","objectID":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/:1:2","tags":["JavaScript"],"title":"javascript中继承的几种实现方法","uri":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"},{"categories":["前端篇"],"content":"3.组合继承 组合继承集合了原型链和盗用构造函数，将两者的优点集中起来，基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性，这样既可以把方法定义在原型上，实现重用，又可以让每个实例都有自己的属性。 function Animal(name) { this.name = name; this.color = ['yellow', 'black']; } Animal.prototype.getName = function () { console.log(this.name); } function Bird(name, age) { Animal.call(this, name); this.age = age; } Bird.prototype = new Animal(); Bird.prototype.constructor = Bird; let b1 = new Animal('bird1'); console.log(b1); //{\"name\":\"bird1\",\"color\":[\"yellow\",\"black\"]} let b2 = new Animal('bird2'); b2.color.push('white'); console.log(b2);{\"name\":\"bird2\",\"color\":[\"yellow\",\"black\",\"white\"]} ","date":"2022-07-22","objectID":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/:1:3","tags":["JavaScript"],"title":"javascript中继承的几种实现方法","uri":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"},{"categories":["前端篇"],"content":"4.寄生组合继承 使用原型工厂封装继承 function extend(child, parent) { child.prototype = Object.create(parent.prototype) child.prototype.constructor = child; } function Animal(name, age) { this.name = name; this.age = age; this.color = ['black', 'gray'] } Animal.prototype.getColor = function () { console.log(this.color); } function Dog(name, age) { Animal.apply(this, [name, age]) } extend(Dog, Animal) let d = new Dog('Dh', 5); console.log(d); // Dog {name: 'Dh', age: 5, color: Array(2)} d.getColor(); // ['black', 'gray'] ","date":"2022-07-22","objectID":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/:1:4","tags":["JavaScript"],"title":"javascript中继承的几种实现方法","uri":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"},{"categories":["前端篇"],"content":"5.class类实现继承使用super关键字实现继承 extends就是class类实现继承的核心。 子类必须在constructor方法中调用super方法，且super方法需要放到第一行。 class Animal { constructor(name) { this.name = name; } getName() { console.log(this.name);; } } class Dog extends Animal { constructor(name, color) { super(name) this.color = color; } } let d = new Dog('Dh', 'white'); console.log(d); // Dog {name: 'Dh', color: 'white'} d.getName(); // Dh ","date":"2022-07-22","objectID":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/:1:5","tags":["JavaScript"],"title":"javascript中继承的几种实现方法","uri":"/posts/20220722-javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"},{"categories":["前端篇"],"content":"在uniapp中访问外部链接由两种方法: 第一是通过webview,在需要跳转的页面通过uni.navigateTo()跳转,跳转时需要加上url地址,在webview界面需要接受url地址并且动态绑定给webview标签,这种方法是在app内部显示外部链接页面,具体代码如下所示: // 跳转前页面 \u003ctemplate\u003e \u003cview\u003e \u003cbutton @tap=\"go\"\u003e跳转到外部\u003c/button\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { go(){ let url= encodeURIComponent('https://www.baidu.com'); uni.navigateTo({ url: '../webView/webView?url=' + url, }) } } } \u003c/script\u003e //webview页面 \u003ctemplate\u003e \u003cview\u003e \u003cweb-view :src=\"url\" :progress=\"true\"\u003e\u003c/web-view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { url:'', } }, onLoad(option) { this.url = decodeURIComponent(option.url); }, } \u003c/script\u003e web-view 是一个 web 浏览器组件，可以用来承载网页的容器，会自动铺满整个页面（nvue 使用需要手动指定宽高）。 第二种方法是同步外部浏览器来进行链接的访问plus.runtime.openURL(url);具体代码如下: \u003ctemplate\u003e \u003cview\u003e \u003cbutton @tap=\"go\"\u003e跳转到外部\u003c/button\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { go(){ let url= 'https://www.baidu.com'; plus.runtime.openURL(url); } } } \u003c/script\u003e 如果是对页面进行简单的浏览推荐第一种方法,就用户体验来说比较友好 ","date":"2022-07-20","objectID":"/posts/20220720-uniapp%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2/:0:0","tags":["uniapp"],"title":"uniapp跳转到指定页面","uri":"/posts/20220720-uniapp%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2/"},{"categories":["版本管理"],"content":"git提交每次都需要填写github帐号密码，解决方式 使用命令 git remote -v 命令行反馈 origin [https://gitee.com/xxx/xxx.git](https://gitee.com/plumliil/lii-ui.git) (fetch) origin [https://gitee.com/xxx/xxx.git](https://gitee.com/plumliil/lii-ui.git) (push) 改为ssh链接即可解决问题 复制ssh 移除原有的提交方式 git remote rm origin 添加ssh提交方式 git remote add origin git@github.com:xxx/xxx.git fatal: 当前分支 main 没有对应的上游分支。 为推送当前分支并建立与远程上游的跟踪，使用 git push --set-upstream origin main 枚举对象: 71, 完成. 对象计数中: 100% (71/71), 完成. 使用 8 个线程进行压缩 压缩对象中: 100% (50/50), 完成. 写入对象中: 100% (55/55), 7.00 KiB | 3.50 MiB/s, 完成. 总共 55 （差异 24），复用 0 （差异 0） remote: Resolving deltas: 100% (24/24), completed with 9 local objects. To github.com:xxx/xxx.git xxxxxx..xxxxxx main -\u003e main 分支 'main' 设置为跟踪来自 'origin' 的远程分支 'main'。 提交成功 ","date":"2022-07-10","objectID":"/posts/20220710-git%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98/:0:0","tags":["Git","踩坑记录"],"title":"git提交问题","uri":"/posts/20220710-git%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98/"},{"categories":["前端篇"],"content":"webpack.config.js基本配置 webpack.config.js是webpack的配置文件,在此文件中对项目入口,项目的输出,loader,插件以及环境等进行简单的配置 首先来对webpack的五个核心概念进行介绍 entry:入口,说明了项目以哪个文件为入口开始对项目进行打包,分析构建内部依赖图, main:单个入口语法 可以简写为 entry:'' pageOne,pageTwo… 告诉我们webpack需要多个独立分离依赖图,多页面应用但是根据经验,每个 HTML 文档只使用一个入口起点。 output:输出 通过配置此项可以规定webpack打包后资源输出到哪里以及如何命名 filename:用于输出文件的文件名 path:目标输出目录的绝对路径,通常与path模块连用 loader:通过loader可以让webpack去处理非javascript资源(webpack本身只能处理javascript) test:使用loader匹配的文件 use:使用多个loader,以数组的形式出现 loader:当处理某一类型文件只需要一种loader时可以使用 options:对loader进行一些配置 plugins:插件,通过插件,可以增加webpack打包能力.插件的范围包括从打包优化到压缩,一直到重新定义变量 mode:模式mode指示webpack执行相应的模式配置,常见模式为development,production webpack构建工具是基于node.js平台运行,模块化默认采用commonjs 基本配置如下: const {resolve}=require('path'); module.exports={ entry:'./src/index.js', output:{ filename:'built.js', path:resolve(__dirname,'build') }, module:{ rules:[ // 详细的loader配置 ] }, plugins:[ // 详细的plugin配置 ], mode:'development' } 常见的loader html html-loader:处理html文件的img图片 (负责引入img图片,从而能被url-loader处理) 样式 style-loader:创建一个style标签,将js中的css样式资插入,添加到页面中生效 css-loader:将css文件以字符串形式变成commonjs模加载到js中,里面内容是 sass-loader:处理sass/scss文件 lass-loader:处理lass文件 postcss-loader:对css文件进行兼容性处理 其他资源 url-loader:协助打包资源文件,可以将图片通过base64方法引入到代码中,url-loader依赖file-loader,所以这两个loader都需要下载 file-loader:对图片视频音频等资源进行打包 常见plugin HtmlWebpackPlugin:当使用 webpack打包时，创建一个 html文件，并把webpack打包后的静态文件自动插入到这个 html文件当中。 MiniCssExtractPlugin:将css样式提取到单独样式中,可以在插件中设置提取到的文件目录. 资源打包 资源打包依赖于各种loader和plugin,通过loader和plugin的配合最终打包出需要的文件. 样式资源打包 根据样式选择加载器style-loader,css-loader必选less-loader,sass-loader, module: { rules: [ // less { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'], }, // css // 样式文件和js文件一起 { test: /\\.css$/, use: ['style-loader', 'css-loader'], }, ], } html文件打包 用到了html-loader处理html文件,同时用到了插件html-webpack-plugin,部分代码如下 const HtmlWebpackPlugin = require('html-webpack-plugin') // export default module: { { test: /\\.html$/, // 处理html文件的img图片 (负责引入img图片,从而能被url-loader处理) loader: 'html-loader', }, }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html' }) ], 图片文件打包 主要用到了url-loader,但是url-loader依赖file-loader,所以这两个loader都需要下载 在options进行了配置 limit:限制多大以下的图片进行base64打包 name:定义图片的名字,可以调整hash值的长度 esModule:是否按照es6模块化打包,默认为true outputPath:打包后的文件放置路径 module:{ rules:[ // img { test: /\\.(jpg|png|gif|jpeg)$/, loader: 'url-loader', options: { limit: 8 * 1024, name: '[hash:10].[ext]', // 关闭es6模块化 esModule: false, outputPath:'imgs' } }, ] }, 其他资源打包 主要用到了file-loader module:{ rules:[ { exclude: /\\.(html|css|jpg|jpeg|png|gif)$/, loader: 'file-loader', options: { name: '[hash:10].[ext]', outputMedia:'media' } } ] }, devServer 开发服务器:devServer devServer: { // 项目路径 static: { directory: resolve(__dirname, 'build'), }, // 启动gzip压缩 compress: true, // 端口号 port: 3000, // 自动打开浏览器 open:true } static:该配置项允许配置从目录提供静态文件的选项（默认是 ‘public’ 文件夹）。将其设置为 false 以禁用： compress:是否启动gzip压缩,默认为false port:执行的端口 open:是否自动打开浏览器,默认为false […][https://webpack.docschina.org/configuration/dev-server/#devserverstatic] 开发环境配置 css样式提取 提取css样式时下载了MiniCssExtractPlugin插件来进行提取,并且将style-loader换成MiniCssExtractPlugin.loader,style-loader主要作用是创建style标签,将css-loader提取的样式放在style标签中,MiniCssExtractPlugin.loader作用是将css样式提取到单独样式中,可以在插件中设置提取到的文件目录.MiniCssExtractPlugin.loader取代style-loader 提取 css 样式为单独文件代码如下 const { resolve } = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = { entry: './src/js/index.js', output: { filename: 'js/built.js', path: resolve(__dirname, 'build') }, module: { rules: [{ test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader' ] }] }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html' }), new MiniCssExtractPlugin({ filename:'css/built.css' }) ], mode: 'development' } css兼容性处理 主要包:postcss-loader,mini-css-extract-plugin postcss-preset-env 帮助postcss找到package.json中browserslist里面配置 npm install postcss-loader postcss-preset-env -D npm install mini-css-extract-plugin -D 通过配置加载指定的css兼容性样式 package.json中配置 \"browserslist","date":"2022-06-09","objectID":"/posts/20220609-%E4%BB%8E%E9%9B%B6%E9%85%8D%E7%BD%AEwebpack%E9%A1%B9%E7%9B%AE/:0:1","tags":["Webpack"],"title":"从零配置Webpack项目","uri":"/posts/20220609-%E4%BB%8E%E9%9B%B6%E9%85%8D%E7%BD%AEwebpack%E9%A1%B9%E7%9B%AE/"},{"categories":["前端篇"],"content":"vuex 什么是状态管理 在开发中,我们会的应用程序需要处理各种各样的数据,这些数据需要保存在我们应用程序中的某一位置,对于这些数据的管理我们称之为是状态管理 在前面是如何管理自己的状态 在前面如何管理自己状态 在Vue开发中,我们使用组件化开发模式 而在组件中我们定义data或者setup中返回使用的数据,这些数据我们称之为state 在模块template中我们可以使用这些数据,模块最终会被渲染成DOM,我们称之为view 在模块中我们会产生一些行为时间,处理这些行为事件时,有可能会修改state,这些行为事件我们称之为actions vuex是什么 vuex是一个专为vuejs应用程序开发的状态管理模式,它采用集中式管理应用的所有组件状态,并以相应的规则保证状态以一种可预测方式发生变化.vuex也集成到vue官方调试工具devtools extension,提供了诸如零配置time-travel调试,状态快照导入导出等高级调试功能 调试工具:devtools vuex就像是眼睛:您自会知道什么时候使用它 vuex的状态管理 管理不断变化的state本身是非常困难的: 状态之间相互会存在依赖, -个状态的变化会引起另一个状态的变化, View页面也有可能会引起状态的变化; 当应用程序复杂时, state在什么时候,因为什么原因而发生了变化,发生了怎么样的变化,会变得非常难以控制和追踪; 因此,我们是否可以考虑将组件的内部状态抽离出来,以一一个全局单例的方式来管理呢? 在这种模式下,我们的组件树构成了一个巨大的“视图View” ; 不管在树的哪个位置,任何组件都能获取状态或者触发行为; 通过定义和隔离状态管理中的各个概念,并通过强制性的规则来维护试图和状态间的独立性,我们的代码边会变得更加结构化和易于维护、跟踪; 单一状态树 vuex使用单一状态树: 用一个对象就包含了全部的应用层级别状态 这也意味着,每个应用将仅仅包含一个store实例 单一状态树和模块化并不冲突 单一状态树优势 如果你的状态是保存到多个Store对象中,那么之后的管理和维护等等都会变得特别困难 所以vuex也使用单一状态树来管理应用层级全部状态 单一状态树能够让我们最直接的方式找到某个状态的片段,而且在之后的维护调试中,也可以非常方便的管理和维护 state 在store中定义数据,在组件中直接使用 目录:store/index.js // store/index.js import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { num: 0 }, mutations: {}, actions: {}, modules: {} }) 目录:Home.vue \u003ctemplate\u003e \u003cdiv class=\"home\"\u003e \u003ch2\u003eHome页面的数字:{{$store.state.num}}\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { } \u003c/script\u003e 或者写为 \u003ctemplate\u003e \u003cdiv class=\"about\"\u003e \u003ch2\u003eAbout页面的数字:{{num}}\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { computed:{ num(){ return this.$store.state.num; } } } \u003c/script\u003e 相当于组件中的数据data,专门用来存放全局数据 更改state中数据唯一办法是提交mutations getters 某些属性我们可能需要经过变化后来使用,这个时候可以使用getters getter第一个参数是state状态,第二个是getters,都可以帮助getters拿到想要的数据 getters相当于组件中的computed.区别是getters是全局的,computed是组件内部使用的在外部使用需要$store.getters.getNums 将组件中统一使用的computed,放到getters中使用 目录:store/index.js export default new Vuex.Store({ state: { num: 0 }, getters:{ getNum(state){ return state.num; } }, mutations: {}, actions: {}, modules: {} }) 目录:Home.vue \u003ctemplate\u003e \u003cdiv class=\"home\"\u003e \u003ch2\u003eHome页面的数字:{{ $store.getters.getNum }}\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default {} \u003c/script\u003e mutations 更改store中state数据状态的唯一方法是提交mutation mutations相当于组件中的methods,但是不能使用异步方法(定时器,axios…) export default new Vuex.Store({ state: { num: 0 }, getters:{ getNum(state){ return state.num; } }, mutations: { // state store中的state payload是一个形参,如果组件在commit时有传参, // 就存在,如果没有传参就为undefined increase(state,payload=1){ state.num+=payload; } }, actions: {}, modules: {} }) 目录:Btn.vue \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton @click=\"add\"\u003e点击+1\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { add(){ // 提交mutation this.$store.commit('increase',3) } }, }; \u003c/script\u003e actions actions是store中专门处理异步的,实际修改状态值的还是mutations actions类似于mutation,不同在于: actions提交的是mutation而不是直接改变状态 actions可以包含任意异步操作 这里有一个非常重要的参数context: context是一个和store实例均有相同方法和属性的context对象 我们可以从其中获取commit方法来提交一个mutation,或者通过context.state和context.getters来获取state和getters 但是它为什么不是store对象,Modules 可以对context进行解构 actions分发 使用store中的dispatch进行分发 目录:store/index.js export default new Vuex.Store({ state: { num: 0 }, getters:{ getNum(state){ return state.num; } }, mutations: { // state store中的state payload是一个形参,如果组件在commit时有传参, // 就存在,如果没有传参就为undefined increase(state,payload=1){ state.num+=payload; }, decrease(state){ state.num--; } }, // 专门处理异步,支持修改状态值的依然是mutations actions: { // 点击 -1 按钮 1s 后执行 decreaseAsync(context){ context.commit('decrease') } }, modules: {} }) 目录:Btn.vue \u003ctemplate\u003e \u003cdiv\u003e \u003cbutton @click=\"$store.commit('increase', 3)\"\u003e点击+1\u003c/button\u003e \u003cbutton @click=\"decrease\"\u003e点击-1\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { decrease() { setTimeout(() =\u003e { this.$store.dispatch(\"decreaseAsync\"); }, 1000); }, }, }; \u003c/script\u003e map 辅助函数 mapState和mapGetters在组件中都是写在computed里 \u003ctemplate\u003e \u003ch2\u003eHome页面的数字:{{ num }}\u003c/h2\u003e \u003ch2\u003eAbout页面的数字:{{getNum}}\u003c/h2\u003e \u003c/template\u003e \u003cscript\u003e import { mapState,mapGetters } from \"vuex\"; export default { computed:{ ...mapState(['num']), ...mapGetters(['getNum']) } }; \u003c/script\u003e mapMutations和mapActions在组件中都是写在methods里 \u003ctemplate\u003e \u003cdiv\u003e \u003cbutt","date":"2022-05-14","objectID":"/posts/20220514-%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8vuex/:0:1","tags":["Vue"],"title":"在vue中使用vuex","uri":"/posts/20220514-%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8vuex/"},{"categories":["前端篇"],"content":"什么是mixin mixin的中文意思是混入,是一种编程思想,在vue中可以通过mixin来分发组件中的可复用功能,当某一个组件使用mixin对象时,该mixin对象的内容就会被混入到组件当中,供组件使用.通过mixin我们可以将公共的方法或者数据抽离出来使用,简化代码,和mixin类似的有vuex状态管理,但是vuex中的数据是所有使用vuex的组件通用的,在某一个组件中改变数据,其他组件中的相应数据也会发生改变,而mixin则不是这样,mixin对象在每个组件使用时互不干扰. 在vue中使用mixin的两种方法 基本使用 在js文件中导出一个对象,对象中包含需要混入的数据或方法,对象中可以包含在vue中使用的生命周期钩子等 const mixin = { data() { return {} }, computed: {}, created() {}, mounted() {}, methods: {}, } 局部混入: 方法会进行覆盖,但是生命周期函数会合并执行,先执行mixin中的生命周期函数内容再执行组件生命周期内容 一个组件中改变了mixin组件中的数据,另一个组件不受影响 // mixin/index.js export const myMixin = { data() { return { msg: '公共数据' } }, computed: {}, created() { console.log('公共created生命周期方法'); }, methods: { clickMe() { console.log(\"公共点击方法\"); }, }, } // A组件 \u003ctemplate\u003e \u003cdiv\u003e \u003ch2\u003eA组件\u003c/h2\u003e \u003cbutton @click=\"clickMe\"\u003eclickMe\u003c/button\u003e \u003cspan\u003e{{ msg }}\u003c/span\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { myMixin } from \"../mixin/index\"; export default { mixins: [myMixin], data() { return { value: \"A组件特有\", }; }, methods: {}, created() { console.log(\"A组件生命周期\"); }, }; \u003c/script\u003e // B组件 \u003ctemplate\u003e \u003cdiv\u003e \u003ch2\u003eB组件\u003c/h2\u003e \u003cbutton @click=\"clickMe\"\u003eclickMe\u003c/button\u003e \u003cspan\u003e{{msg}}\u003c/span\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import {myMixin} from '../mixin/index' export default { mixins: [myMixin], data() { return { value: \"B组件特有\", }; }, methods: { clickMe() { console.log(\"B组件特有方法\"); }, }, created() { console.log(\"B组件生命周期\"); }, }; \u003c/script\u003e // App.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ccpm-a\u003e\u003c/cpm-a\u003e \u003ccpm-b\u003e\u003c/cpm-b\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import cpmA from \"./components/cpmA.vue\"; import cpmB from \"./components/cpmB.vue\"; export default { components: { cpmA, cpmB }, }; \u003c/script\u003e 全局混入: 在main.js中引用 // main.js import {myMixin} from './mixin' Vue.mixin(myMixin) 谨慎使用全局混入,因为它会影响每个单独创建的vue实例包括第三方组件.大多数情况下之应当应用于自定义选项,就像上面的事例一样,推荐将其作为插件发布,以免避免重复应用混入. mixin使用选项合并规则: 1.先执行mixin生命周期函数,再执行组件中生命周期函数. 2.如果data里面数据有冲突,优先使用组件中的数据. 3.当mixin中methods方法和组件方法重名时,优先使用组件方法 mixin优缺点: 优点 1.提高代码复用性 2.无需传递状态 3.维护方便,只修改一个地方即可 缺点: 1.命名冲突 2.滥用mixin后期不易维护 3.不好溯源,排查问题困难 4.不能轻易的重复代码 vue官方mixin讲解:混入 — Vue.js (vuejs.org) ","date":"2022-05-08","objectID":"/posts/20220508-%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8mixin/:0:0","tags":["Vue"],"title":"在vue中使用mixin","uri":"/posts/20220508-%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8mixin/"},{"categories":["前端篇"],"content":"自定义指令 类似于vue中的v-if,v-show,我们也可以自己注册自定义指令,使用directive或者directives注册的指令为自定义指令,自定义指令分为两种,分别是全局自定义指令和局部自定义指令.通过自定义指令我们可以对dom进行底层操作. 自定义指令参数介绍 钩子函数介绍 bind 只调用一次,指令第一次绑定到元素时调用,在这里可进行一次性的初始化设置 inserted 被绑定元素插入父节点调用(保证父节点存在,但不一定被插入到文档中) update 所有组件的VNode更新时调用,但是可能发生在其子VNode更新之前.指令的值可能发生改变,也可能没有 componentUpdated 指令所在组件的VNode及其子VNode全部更新后调用. unbind 只调用一次,指令与元素解绑时调用 钩子函数参数 el:指令绑定到的元素。这可用于直接操作 DOM bindings: instance：使用指令的组件实例。 value：传递给指令的值。例如，在 v-my-directive=“1 + 1” 中，该值为 2。 oldValue：先前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否有更改都可用。 arg：传递给指令的参数(如果有的话)。例如在 v-my-directive:foo 中，arg 为 “foo”。 modifiers：包含修饰符(如果有的话) 的对象。例如在 v-my-directive.foo.bar 中，修饰符对象为 {foo: true，bar: true}。 dir：一个对象，在注册指令时作为参数传递。例如，在以下指令中 vnode:一个真实 DOM 元素的蓝图，对应上面收到的 el 参数 prvenode:上一个虚拟节点，仅在 beforeUpdate 和 updated 钩子中可用。 注意:除了 el 之外，你应该将这些参数视为只读，并且永远不要修改它们。如果你需要跨钩子共享信息，建议通过元素的自定义数据属性集进行共享。 自定义指令分类 全局指令 全局指令只能使用directive单个创建 // main.js directive('example', { // 钩子函数 bind() {}, inserted() {}, updated() {}, componentUpdated(){}, unbind(){} }) 局部指令 局部指令使用directives来定义,directives在script内和data,methdos同级,内部可定义多个指令 \u003cscript\u003e data(){return{}}, methods:{}, directives:{ directiveName1:{ // 钩子函数 }, directiveName2:{ // 钩子函数 }, directiveName3:{ // 钩子函数 }, } \u003c/script\u003e 下方代码使用directives定义了一个resize指令,作用是在浏览器窗口更改时,更改div的大小 \u003ctemplate\u003e \u003cdiv v-resize\u003e \u003ch2\u003e窗口宽度:{{innerWidth}}\u003c/h2\u003e \u003ch2\u003e窗口高度:{{innerHeight}}\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: \"App\", data() { return { innerWidth:window.innerWidth, innerHeight:window.innerHeight, } }, directives: { resize:{ bind(){ console.log('bind'); }, inserted(el,binding,vnode){ console.log('inserted'); const sizeChange=function (){ this.innerWidth=window.innerWidth; this.innerHeight=window.innerHeight; el.style.width=this.innerWidth*0.7+'px'; } window.addEventListener('resize',sizeChange.bind(vnode.context)) }, updated() { console.log('updated'); }, componentUpdated(){ console.log('compontentUpdated'); }, unbind(){ console.log('unbind'); } } }, }; \u003c/script\u003e 自定义指令简写 Vue.directive('example', function(el, binding){}) 这里的 function 等同于将代码写在了 bind 和 update 钩子函数中。 自定义指令示例 复制指令,点击元素节点复制内容 \u003ctemplate\u003e \u003cp v-copy\u003e Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。 Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 \u003c/p\u003e \u003c/template\u003e \u003cscript\u003e export default { directives: { copy: function (el) { el.addEventListener(\"click\", () =\u003e { let textareaCopy = document.createElement(\"textarea\"); textareaCopy.setAttribute(\"readonly\", \"readonly\"); textareaCopy.style.opacity = 0; textareaCopy.value = el.innerText; document.body.appendChild(textareaCopy); textareaCopy.select(); let copyText = document.execCommand(\"copy\"); document.body.removeChild(textareaCopy); console.log(\"复制成功\"); return copyText; }); }, }, }; \u003c/script\u003e \u003cstyle\u003e p { width: 400px; text-indent: 32px; text-align: left; border: 1px solid #f0f0f0; padding: 3px; cursor: pointer; } \u003c/style\u003e 实现简单弹窗指令 \u003ctemplate\u003e \u003cdiv\u003e \u003cspan class=\"tip\" v-tip:[tipSite1]=\"tipValue1\"\u003etip\u003c/span\u003e \u003cspan class=\"tip\" v-tip:[tipSite2]=\"tipValue2\"\u003etip\u003c/span\u003e \u003cspan class=\"tip\" v-tip:[tipSite3]=\"tipValue3\"\u003etip\u003c/span\u003e \u003cspan class=\"tip\" v-tip:[tipSite4]=\"tipValue4\"\u003etip\u003c/span\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { tipSite1: \"top\", tipValue1: \"上方提示\", tipSite2: \"bottom\", tipValue2: \"下方提示\", tipSite3: \"left\", tipValue3: \"左侧提示\", tipSite4: \"right\", tipValue4: \"右侧提示\", }; }, directives: { tip: function (el, binding) { console.log(binding); const createTip = () =\u003e { let tipWindow = document.createElement(\"p\"); tipWindow.className = \"tipWindow\"; switch (binding.arg) { case \"top\": tipWindow.style.top = \"-85%\"; tipWindow.style.left = \"18%\"; break; case \"bottom\": tipWindow.style.top = \"110%\"; tipWindow.style.left = \"18%\"; break; case \"left\": tipWindow.style.top = \"12%\"; tipWindow.style.left = \"-72%\"; break; case \"right\": tipWindow.style.top = \"12%\"; tipWindow.style.left = \"103%\"; break; default: tipWindow.style.top = \"-90%\"; tipWindow.style.left = \"18%\"; break; } tip","date":"2022-04-30","objectID":"/posts/20220430-%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/:0:0","tags":["Vue"],"title":"在vue中使用自定义指令","uri":"/posts/20220430-%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"categories":["前端篇"],"content":"在JavaScript中有五种常用的循环，现在来分别介绍一下五种循环的用法。 ","date":"2022-04-23","objectID":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["JavaScript"],"title":"Js中几种循环的使用","uri":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["前端篇"],"content":"1.while 当满足条件时进入循环，进入循环后，当条件不满足时，跳出循环。while语句的一般表达式为：while（表达式）{循环体}。 let num = 0; while (num \u003c 5) { num++; console.log(num); } // 1 // 2 // 3 // 4 // 5 while (num \u003e 5) { num++; console.log(num); } // 5 // 4 // 3 // 2 // 1 ","date":"2022-04-23","objectID":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:0:1","tags":["JavaScript"],"title":"Js中几种循环的使用","uri":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["前端篇"],"content":"2.do…while do {循环体} while（表达式） 用法和while相差不大，但有特殊的一点是当while后条件表达式为false时，do内的循环体仍然会执行一次 let num = 0; do { num++; console.log(num); } while (num \u003c 5) // 1 // 2 // 3 // 4 // 5 do { num++; console.log(num); } while (num \u003e 5) // 1 ","date":"2022-04-23","objectID":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:0:2","tags":["JavaScript"],"title":"Js中几种循环的使用","uri":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["前端篇"],"content":"3.for for循环是平时用法最多的循环，for循环的循环语句由循环体及循环的判定条件两部分组成，其表达式为：for（单次表达式;条件表达式;末尾循环体）{中间循环体；}。因为for循环的单次表达式，条件表达式，末尾循环体可以使用不同的形式，所以for循环很灵活,有多种变式。 shilet num = 0; // 最基本的用法 for (let i = 5; i \u003e num; i--) { console.log(i); } // 当单次表达式写在判断条件外部时 let i=5; for(;i\u003enum;i--){ console.log(i) } // 当单次表达式和条件表达式写在判断条件外部时 for(;;i--){ if(i\u003e0){ console.log(i); }else{ break } } for(;true;){ if(i\u003e0){ console.log(i); }else{ break } i--; } // 当作while循环使用 // 死循环 一直打印 for for(;true;){ onsole.log('for'); } ","date":"2022-04-23","objectID":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:0:3","tags":["JavaScript"],"title":"Js中几种循环的使用","uri":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["前端篇"],"content":"for…of… for…of…通常用来遍历传入对象的属性值，前提传入的对象是一个可迭代对象，不可迭代对象需要转为可迭代对象再遍历. let arr = [1, 'a', '2', 3, 'b']; let obj = { name: 'aa', age: 11 } for (const value of arr) { console.log(value); } // 1 // a // '2' // 3 // b for (const value of obj) { console.log(value); } // TypeError: obj is not iterable 提示obj不是可迭代对象 使用for…of…可以消耗迭代器 // o为生成斐波那契数列的一个迭代器对象 let o = { n1: 1, n2: 1, [Symbol.iterator]() { return this }, next() { let current = this.n2; this.n2 = this.n1; this.n1 = this.n1 + current; if(current\u003e10) return {value: current,done: true} return {value: current,done: false} } } for (const v of o) { console.log(v); } // 1 // 1 // 2 // 3 // 5 // 8 ","date":"2022-04-23","objectID":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:0:4","tags":["JavaScript"],"title":"Js中几种循环的使用","uri":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["前端篇"],"content":"for…in… for…in…通常来遍历传入对象的属性名，该循环没有对对象是否可迭代的要求 let arr = [1, 'a', '2', 3, 'b']; let obj = { name: 'aa', age: 11 } for (const key in arr) { console.log(key); } // 0 // 1 // 2 // 3 // 4 for (const key in obj) { console.log(key); } // name // age ","date":"2022-04-23","objectID":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:0:5","tags":["JavaScript"],"title":"Js中几种循环的使用","uri":"/posts/20220423-js%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["前端篇"],"content":"什么是Promise Promise是异步编程的一个解决方案：从语法上讲它是一个对象，可以获取到异步操作的消息，从本意上讲，它是一个承诺，承诺过一段时间后它会给你一个结果。Promise有三种状态：pending(等待)，fulfilled(成功)，rejected(失败)，状态一旦改变就不会再变，创建Promise后会立即执行。 ","date":"2022-04-17","objectID":"/posts/20220417-%E8%AE%A4%E8%AF%86promise/:0:1","tags":["JavaScript"],"title":"认识Promise","uri":"/posts/20220417-%E8%AE%A4%E8%AF%86promise/"},{"categories":["前端篇"],"content":"为什么要使用Promise 避免回调地狱 // 请求 代表 一个异步网络调用。 // 请求结果 代表网络请求的响应。 请求1(function(请求结果1){ 请求2(function(请求结果2){ 请求3(function(请求结果3){ 请求4(function(请求结果4){ 请求5(function(请求结果5){ 请求6(function(请求结果3){ ... }) }) }) }) }) }) 解决办法 new Promise(请求1) .then(请求2(请求结果1)) .then(请求3(请求结果2)) .then(请求4(请求结果3)) .then(请求5(请求结果4)) .catch(处理异常(异常信息)) ","date":"2022-04-17","objectID":"/posts/20220417-%E8%AE%A4%E8%AF%86promise/:0:2","tags":["JavaScript"],"title":"认识Promise","uri":"/posts/20220417-%E8%AE%A4%E8%AF%86promise/"},{"categories":["前端篇"],"content":"Promise 的常用 API Promise.resolve(value) 类方法，该方法返回一个以 value 值解析后的 Promise 对象 1、如果这个值是个 thenable（即带有 then 方法），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指fulfilled/rejected/pending） 2、如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。 3、其他情况以该值为成功状态返回一个 Promise 对象。 let p0=Promise.resolve('success'); p0.then( res=\u003e{ console.log(res); }, err=\u003e{ console.log(err); } ) // success // 和p1效果相同 let p1=new Promise((resolve,reject)=\u003e{ resolve('success') }) p1.then( res=\u003e{ console.log(res); }, err=\u003e{ console.log(err); } ) // success //如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。 function fn(resolve){ setTimeout(function(){ resolve(123); },3000); } let p2 = new Promise(fn); let p3 = Promise.resolve(p2); // 返回为true，返回的 Promise 即是 入参的 Promise 对象。 console.log(p2 === p3); // true Promise.reject 类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。 Promise.prototype.then 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。 Promise.prototype.catch 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。 let p=Promise.resolve('0 success'); p.then( res=\u003e{ console.log(res); return '1 success' } ) .then(res=\u003e{ console.log(res); throw new Error('2 error') }) .catch(err=\u003e{ console.log('catch',err); }) // 0 success // 1 success // catch Error: 2 error catch方法可以统一捕获then链式调用中产生的错误 Promise.finally 实例方法，用于指定不管Promise对象最后状态如何，都会执行的操作，不管Promise最后的状态，在执行完then或者catch指定的回调以后都会执行finally方法。可以进行任何必要的清理工作 let p=Promise.resolve('0 success'); p.then( res=\u003e{ console.log(res); return '1 success' } ) .then(res=\u003e{ console.log(res); throw new Error('2 error') }) .catch(err=\u003e{ console.log('catch',err); }) .finally(()=\u003e{ console.log('p finally'); }) // 0 success // 1 success // catch Error: 2 error // p finally Promise.all([…]) 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。 。 let p1 = Promise.resolve('p1 success'); let p2 = Promise.resolve('p2 success'); let p3 = Promise.reject('p3 error') let arr = [p1, p2, p3] Promise.all(arr) .then( res =\u003e { console.log(res); }, err =\u003e { console.log(err); } ) // p3 error Promise.race([…]) 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。 let p1 = Promise.resolve('p1 success'); let p2 = Promise.resolve('p2 success'); let p3 = Promise.reject('p3 error') let arr = [p1, p2, p3] Promise.race(arr) .then( res =\u003e { console.log(res); }, err =\u003e { console.log(err); } ) // p1 success Promise.any([…]) 与all相似，但是会忽略拒绝，所以只需要完成一个而不是全部 let p1 = Promise.reject('p1 error'); let p2 = Promise.resolve('p2 success'); let p3 = Promise.reject('p3 error') let arr = [p1, p2, p3] Promise.any(arr) .then( res =\u003e { console.log(res); }, err =\u003e { console.log(err); } ) // p2 success 变式 Promise.none([…]) 类似于all不过完成和拒绝的情况互换，只有所有的函数都被拒绝，该函数转化为完成值，反之亦然 Promise.first([…]) 类似于any的竞争，只要第一个Promise完成，会忽略后边任何的拒绝和完成 Promise.last([…]) 类似于first，但是只有最后一个完成胜出 ","date":"2022-04-17","objectID":"/posts/20220417-%E8%AE%A4%E8%AF%86promise/:0:3","tags":["JavaScript"],"title":"认识Promise","uri":"/posts/20220417-%E8%AE%A4%E8%AF%86promise/"},{"categories":["前端篇"],"content":"BFC(块级格式化上下文) 什么是BFC 指的是一个块级渲染作用域,该区域内拥有一套完整的规则来约束块级盒子的布局,且与区域外部无关. 为什么要使用BFC 当一个盒子不设置高度,当其中的子元素都浮动时,这个盒子便无法撑起自身. 这个问题可以使用BFC来解决,形成一个块级格式化上下文. 那么如何创建BFC float的值不为none position的值不为static或relative display的值为inline-block,flex,inline-flex 设置overflow:hidden BFC的其他作用 取消盒子的margin塌陷 如图所示,父元素盒子不做设置,当子盒子设置margin-top后,父元素盒子也会随之变化. 此时给父元素设置overflow:hidden创建块级格式化上下文可以有效解决margin塌陷问题 清除浮动 如图所示,当父盒子中有元素浮动,有元素不浮动时,不浮动的元素会出现在浮动元素下方此时给浮动元素设置overflow:hidden可以清除浮动,显示出不浮动元素. 当然清除浮动还有其他几种方法,这些后续再谈 ","date":"2022-04-10","objectID":"/posts/20220410-%E4%BB%80%E4%B9%88%E6%98%AFbfc/:1:0","tags":["Css"],"title":"什么是BFC","uri":"/posts/20220410-%E4%BB%80%E4%B9%88%E6%98%AFbfc/"},{"categories":["前端篇"],"content":"在javascript中this绑定有以下几种方式 默认绑定 function foo(){ console.log(this.a); } var a = 1; foo(); // 1 以上绑定代码即为this的默认绑定,当函数没有其他绑定时,此时this指向window对象; 隐式绑定 隐式绑定需要考虑的是调用位置是否有上下文对象.如下代码所示: function foo(){ console.log(this.a); } var obj = { a:'obj', foo:foo } obj.foo(); // obj 在上述代码中foo函数作为一个值被赋予到了obj对象的foo属性中,此时的this指向obj这个对象,调用时 打印的this.a为obj.a为obj;再如下代码 function foo() { console.log(this.a); } var obj2 = { a: 'obj2', foo: foo } var obj1 = { a: 'obj1', obj2: obj2 } obj1.obj2.foo(); // obj2 foo函数是obj2中foo属性的值,上述代码中obj1通过调用自己的obj2属性来调用obj2.foo,打印出的值是obj2,可见对对象属性引用链中只有上一层或者说是最后一层在调用位置起作用 隐式丢失 ​ 在隐式绑定中存在隐式丢失这个问题,被隐式绑定的函数会丢失其隐式绑定对象,也就是说此时函数会应用默认绑定,从而把this绑定到全局对象或者undefined上,取决于是否为严格模式; function foo() { console.log(this.a); } function doFoo(fn) { fn(); } var obj = { a: 'obj', foo: foo } var a = 'global this'; doFoo(obj.foo); // global this doFoo.call(window,obj.foo); // global this ​ 在上述代码中调用doFoo传入obj.foo此时fn=obj.foo(在AO对象中)可以看作一个隐式赋值,此时doFoo的this指向window,所以打印出来golbal this ​ 如果把函数传入语言内置的函数而不是自己声明的函数,结果是一样的,比如setTimeout函数: setTimeout(obj.foo,100); // global this // 伪代码如下 // function setTimeout(fn,delay) { // // 等待delay // fn(); // } 显示绑定 显示绑定可以借助call,apply函数完成,代码如下: function foo(){ console.log(this.a) } var obj = { a:'obj' } foo.call(obj); // obj foo.apply(obj); // obj ​ 通过调用call或apply可以在调用foo时前置把它的this绑定到obj上; ​ 在这里还有个概念装箱:如果传入了一个原始值(字符串类型,布尔类型或者数字类型)来当做his的绑定对象,这个原始值会被转换成它对应的对象形式(new String()…). 但显示绑定也无法解决丢失绑定的问题,此时显示绑定的一个变种硬绑定可以解决这个问题 硬绑定 function foo() { console.log(this.a); } var obj = { a: 'obj' } var bar = function () { return foo.call(obj) } bar(); ​ 在上述代码中创建了一个bar函数,每次调用bar都会在obj上调用foo这种绑定是一种显示强制绑定,称之为硬绑定. ​ 硬绑定的典型应用场景就是创造一个包裹函数,负责接收参数并返回值,由于硬绑定是一种非常常用的模式,所以es5提供了内置方法Function.prototype.bind,应用方法如下 function foo(something) { console.log(this.a + something); } var obj = { a: 'obj' } foo.bind(obj)(' something'); // obj somehing bind会返回一个硬编码的新韩淑,它会把指定参数者只为this上下文并调用原始函数; new绑定 function foo(a){ this.a = a; } var bar = new foo(2); console.log(bar.a); // 2 使用new调用foo时会构造一个新对象并把它绑定到foo调用中的this上.new是最后一种可以影响函数调用时this绑定行为的方法. 读《你不知道的JavaScript 上卷》笔记记录 ","date":"2022-04-08","objectID":"/posts/20220408-this%E7%9A%84%E7%BB%91%E5%AE%9A/:0:0","tags":["JavaScript"],"title":"this的绑定","uri":"/posts/20220408-this%E7%9A%84%E7%BB%91%E5%AE%9A/"},{"categories":["前端篇","优化篇"],"content":"渲染几万条数据不卡就不能将数据一次性的渲染出来,而是需要分段渲染,一次渲染20条,30条,50条等,来分多次渲染. 先把代码贴出来然后再一一解释: \u003col\u003e\u003c/ol\u003e setTimeout(()=\u003e{ // Ⅰ定义变量 let totalData = 10000; let once = 20; let renderCount = 0; let loopCount = Math.ceil(totalData / once); let ol = document.querySelector('ol'); // Ⅱ渲染 function renderData(){ let fragment = document.createDocumentFragment(); for(let i=0;i\u003conce;i++){ let li = document.createElement('li'); li.innerHTML=Math.floor(Math.random()*totalData); fragment.appendChild(li); } ol.appendChild(fragment); renderCount+=1; loop(); } // Ⅲ循环 function loop(){ if(loopCount\u003crenderCount){ window.requestAnimationFrame(renderData); } } // Ⅳ开始渲染 loop(); },0) ​ 这一串代码由setTimeout()函数包裹,setTimeout是一个计时器,在此函数内的代码是宏任务,需要在主线任务和微任务(不是宏任务所含微任务)执行完后再执行,这在一定程度上提高了友好度,不需要等待数据渲染完之后才继续渲染后续的界面,而setTimeout延时时间设置为0就是为了让主页面渲染完后第一个渲染数据. Ⅰ定义变量 ​ 在这部分内对变量进行一些定义,在此需要获取到待渲染数据的总数,一次性渲染数据条数,需要渲染的次数以及循环次数,当然还有少不了的Dom节点,这些数据可以根据自己需要进行更改. Ⅱ渲染 ​ 在渲染这部分中定义了一个渲染函数,在此渲染函数内使用createDocumentFragment() 方法创建了一个虚拟的节点对象fragment,将渲染的li节点加入到fragment这个虚拟的节点对象中,在我看来,这个虚拟对象可以看作一个容器,我们可以把需要渲染的部分数据先放到容器中,然后在将这个容器放入到对应的父节点中,在该例子中父节点是ol,这样做的好处是防止每一次li生成后就立即插入到ol中,使浏览器进行重绘,而在数据较多的情况下浏览器的页面的重绘会大大的损耗浏览器的性能.而先将li放入fragment这个虚拟节点再将fragment放入ol可以减少20倍(在本例子中是20倍)的重绘次数,提高执行效率; ​ 同时,在渲染函数内也调用了一下循环函数来判断是否结束渲染. Ⅲ循环 ​ 在循环这部分同样定义了一个函数来进行循环判断操作,当renderCount的次数大于loopCount时停止渲染, window.requestAnimationFrame() 要求浏览器在下次重绘之前调用指定的回调函数更新动画,具体用法可去往window.requestAnimationFrame - Web API 接口参考 | MDN (mozilla.org) Ⅳ开始渲染 ​ 在此调用一次loop函数开始数据的渲染. 总结 ​ 这个问题考察了任务队列,createDocumentFragment()以及window.requestAnimationFrame()这两个方法,同时还用到了重绘的知识,开阔了思路. ","date":"2022-04-05","objectID":"/posts/20220405-%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E5%87%A0%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%B8%8D%E5%8D%A1%E4%BD%8F%E7%95%8C%E9%9D%A2/:0:0","tags":["JavaScript"],"title":"如何渲染几万条数据并不卡住界面","uri":"/posts/20220405-%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E5%87%A0%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%B8%8D%E5%8D%A1%E4%BD%8F%E7%95%8C%E9%9D%A2/"},{"categories":["计网篇"],"content":"TCP/IP 协议:一种规则,规定不同计算机操作系统,硬件之间怎么通信的一种规则 像这样把互联网相关联的协议集合起来总称为TCP/IP协议. TCP/IP分层管理 按照组层次分为以下四层: 应用层:决定了向用户提供应用服务时通信的活动 tcp/ip协议族内预存了各类通用应用服务比如FTP和DNS等 传输层:对上层应用层,提供处于网络连接中两台计算机之间的数据传输. 在传输层有两个性质不同的协议:TCP和UDP 网络层:又名网络互联层有,用来处理网络上流动的数据包 数据包使网络传输的最小数据单位.该层规定了通过怎样的路径(传输路线到达对方计算机),并把数据包传给对方. 与对方计算机之间通过多台计算机或者网络设备进行传输时,网络层所起的作用就是在众多的选项内选择一条传输路线 数据链路层:又称链路层,数据接口层,用来处理链接玩罗德硬件部分,包括操作系统,赢家的驱动,NIC,及光纤等物理可见部分.硬件范畴均在链路层作用范围内. 分层好处:使设计更加简单,给每个层分配不同的任务 通信传输流 ​ 客户端 \u003c—\u003e 应用层(HTTP客户端)① \u003c—\u003e 传输层(TCP)② \u003c—\u003e 网络层(IP)③ \u003c—\u003e 链路层(网络)④ \u003c—\u003e 链路层(网络)④ \u003c—\u003e 网络层(IP) \u003c—\u003e 传输层(TCP) \u003c—\u003e 应用层(HTTP服务器端) \u003c—\u003e 服务端 ①:http协议发送请求 ②:tcp协议对在应用层收到的数据(http请求报文)进行分割,并在各个报文上打上标记序号及端口号 发送给网络层 ③:增加作为通信目的地的MAC地址后转发给链路层 ④:接受端的服务器在链路层收到服务端发送的数据,按顺序往上发送一直到应用层,才算真正接收端由客户端发送过来的http请求 ​ 在http数据从应用层发出后,之后的每一层都会对其进行封装,在传输层进行TCP首部的封装,在网络层进行IP首部的封装,在数据链路层进行以太网首部封装,在服务端的数据链路层接收到数据后会将这些封装一一消去. IP,TCP和DNS IP网际协议位于网络层,作用是通过ip地址和mac地址将各种数据包传给对方,其中ip地址指明了节点被分配到的地址,mac地址是指网卡所属的固定地址,ip地址可以和mac地址进行配对,ip地址可换但是mac地址基本上不会更改. ​ TCP:tcp协议位于传输层,提供可靠的字节流服务(所谓字节流服务是为了方便传输,将大数据块分割成以报文段为单位的数据包进行管理,将报文段传递给对方),为了将数据准确无误的送达,TCP协议采用了三次握手策略(发送端将标有SYN的数据包发送给服务端,服务端接收到数据包后发送标有SYN/ACK的数据包给发送端,发送端接收到数据包后发送带有SYN的数据包.SYN-synchronize,ACK-acknowledgement) ​ DNS服务是和HTTP协议一样位于应用层,提供域名到ip地址之间的解析.使由数字组成的ip地址可以用有含义的字母单词来表示,而DNS做的就是将这些容易理解的字母单词解析为ip地址 各协议与HTTP协议之间关系 以访问https:www.plumli.xyz/为例: ​ 客户端通过DNS解析获得https:www.plumli.xyz/所对应的IP地址—\u003eHTTP协议生成针对目标web服务器的HTTP请求报文—\u003eTCP为了方便通信将报文分割成报文段,把每个报文段可靠的传输给对方—\u003e根据ip地址在路由器中进行中转—\u003e客户端接收到报文段,根据TCP协议对报文段进行重组,并对请求内容进行处理—\u003e最后将处理过的内容通过TCP/IP协议向用户进行回转. URI和URL URI:统一资源标识符,用字符串标识某一互联网资源 URI格式:http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1 http:协议方案名 user:pass登录信息认证(可选) www.example.com:服务器地址 80:服务器端口 dir/index.html:文件路径 uid=1查询字符串 ch1片段标识符 URL:统一资源定位符,表示资源在互联网上所处的位置 读《图解HTTP》笔记记录 ","date":"2022-04-04","objectID":"/posts/20220404-%E4%BA%86%E8%A7%A3web%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:0:0","tags":["网络基础"],"title":"了解web网络基础","uri":"/posts/20220404-%E4%BA%86%E8%A7%A3web%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["前端篇"],"content":"​ 吃什么饭对于有选择困难的我来说是个大问题,所以想做个根据自己输入的食物随机分配每餐吃的东西,然后就准备用uniapp做这样一个软件,主要是uniapp打包生成移动端app比较方便.然后就去看了一下uniapp,就像把这两天敲代码遇到的问题及心得总结一下. ​ 总的来书uniapp的开发和vue的开发差不多,所以用起来也就很快的熟练了起来,但是有些组件以及api的调用还是不同 ​ 首先从uniapp新建项目开始吧,因为我要做的是uni-app所以就选择了默认的模板.然后来看一下 uniapp基本目录结构 │ App.vue │ index.html │ main.js │ manifest.json │ pages.json │ uni.scss ├─commons │ ├─css │ ├─imgs │ └─js ├─components │ └─eatWhat ├─pages │ └─index ├─static └─util ​ App.vue 是uni-app的主组件，所有页面都是在 App.vue 下进行切换的，是页面入口文件,和vue中的.App.vue类似,也有些不同,uniapp的App.vue页面中没有tempate模板,而是只有script和style这两个标签,uniapp页面中公共的样式可以放在Vue.app这个页面的style中.index.html是运行之后生成的,所有的东西都会渲染到这上面,manifest.json进行一些基础的配置,pages.json中是配置一些页面信息,导航栏信息等uni.scss是一些公共样式的配置.在使用scss是可以方便的引用 ​ 文件夹中commons和components,util这三个文件夹是我自己创建的commons是放置一些公共的东西,css,js之类的文件,components主要放置一些组件,有vue开发经验的小伙伴应该对这个很熟悉.而util放一些封装的一些工具方法,pages中放的是所有的页面,static中放置静态资源. ​ 说完了基本的目录结构就来说一下最近遇到的问题 储存 ​ 吃点啥这个块用到最多的就是信息的存储与读取,我一开始想到的就是用storage来进行数据的存储,然后再给当日获取到的食物设置过期时间,超过12小时后清空然后就去查了下官方文档,发现只能简单的设置值,没法直接这设置过期时间,所以只能自己来设置. 下面就把代码贴出来: function cache(key, value, time = 3600 * 12) { let nowTime = Date.parse(new Date()) / 1000; if (key \u0026\u0026 value) { // 设置到期时间 let expire = nowTime + Number(time); uni.setStorageSync(key, JSON.stringify(value) + '|' + expire); } else if (key \u0026\u0026 !value) { let val = uni.getStorageSync(key); if (val) { // 判断缓存是否过期 let temp = val.split('|'); if (!temp[1] || temp[1] \u003c= nowTime) { uni.removeStorageSync(key); console.log(key + '缓存已失效'); return ''; } else { return JSON.parse(temp[0]); } } } } uni.getStorageSync(key)和uni.setStorageSync(key,value)是uniapp中同步设置和获取缓存的两个api,我们可以通过在设置值是添加一个设置值的时间,然后在获取值时进行判断,当设置时间-获取时间\u003e过期时间时,缓存无效,通过uni.removeStorageSync移除缓存,以此方法来设置过期时间 字体导入与使用 ​ 另一个问题是字体的导入,因为第一次在uniapp中设置字体,遇到了点困难,所以这个也需要记录下来. ​ 字体导入首先是引入字体,到网上下载了心仪字体的ttf文件.放在了static的font文件夹里 然后又去公共的样式文件中设置了global.css如下: // global.css @font-face { font-family:YangRenDongZhuShiTi; src: url('~@/static/font/xxxxxx.ttf'); } 因为我的字体需要全局引用,所以又到App.vue中设置了一下公共页面的css最后完成字体的设置. 其他的都是一些js逻辑之类,相对较简单,以后遇到问题继续补充… ","date":"2022-03-31","objectID":"/posts/20220331-%E8%BF%91%E6%9C%9Funiapp%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%80%BB%E7%BB%93/:0:0","tags":["uniapp"],"title":"近期uniapp使用及总结","uri":"/posts/20220331-%E8%BF%91%E6%9C%9Funiapp%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%80%BB%E7%BB%93/"},{"categories":["优化篇"],"content":"在此之前先谈谈为什么要对网站进行优化 我认为有两个主要的方面 **一:**为了提高用户的浏览体验,我想没有一个用户在访问网站时等个几秒钟后,网站页面还为加载出来,此时对网站的优化是优化性能,优化交互,使用户喜欢上这个网站,使网站变得更加的友好. 二:为了提升网站的排名,做一个网站最大的目的是为了展示信息,那么如何更好的展示信息呢,这里就需要对网站进行搜索引擎优化(SEO),通过优化提升浏览器在搜索引擎中的排名,使自己的网站优先展示. 接下来说一下怎么对网站进行性能优化 进行性能优化无非是为了提高浏览器的加载速度和渲染速度. 性能优化主要包括两个方面: 网络请求优化 减少HTTP请求:在加载时可以先确定加载的顺序,这个是非常重要的,通过加载顺序可以判断出哪些请求是可以优先加载,哪些请求可以在页面渲染后加载,以此来提升用户体验,减少HTTP加载时间 减小cookie的体积:cookie内有关的信息是放在HTTP请求头中在服务器和浏览器之间交流,保存的cookie越大,请求完成的时间越长,所以通过减小cookie的体积可以来减小用户的响应时间也显得很必要. 使用CDN和DNS:CDN为内容分发网络,主要解决的是如何将数据快速可靠的发给用户,通过CDN的分发,用户可以从较优的服务器获取资源而无需从源站获取,从而达到快速访问,DNS为域名系统,是互联网的一项服务,减少用户的等待时间，提升用户体验(具体有关CDN和DNS的优化可以浏览前端项目性能分析之聊聊DNS和CDN缓存) 静态资源加载优化 将样式放在顶部,JS放在页面底部:用户在进入一个网页是首先看到是内容,浏览器在渲染时会将所有css下载完之后才对页面进行渲染,将样式放在头部可以加快浏览器渲染速度,而将脚本放在底部是为了优先渲染内容,其次再渲染交互 少使用css表达式,虽然css表达式带来了很多方便,但是同时当css表达式计算次数会对性能有所损耗 在html引入css时使用link不使用@import:link是html方式,@import是css方式,link最大限度支持并行下载,@import过多嵌套会导致串行下载,出现文档样式短暂失效,影响用户的体验 图片的优化:图片的加载也会影响浏览器的渲染,我们可以使用精灵图来一次性加载多张图片通过减少http请求来提高渲染速度,当图片较小时可以使用base64格式来加载图片,而当图片较大时可以对图片进行压缩,也可以根据可视区的判断选择对图片进行懒加载 对代码进行打包,减少代码体积 最后来说一下搜索引擎优化 做搜索引擎优化的目的主要是为了提高网站权重,增加流量,改善体验 合理的title,description,keywords:通过对标题描述关键词的设置可以更好地让蜘蛛更好的抓取. 语义化:代码要符合w3c规范,可以使搜索引擎更加容易的理解网页 扁平化目录结构:网站的结构层次越少越容易被蜘蛛抓去,从而被收录,可以通过优化目录结构来进行搜索引擎优化 少用iframe:搜索引擎不会抓取iframe里的内容 … 对网站优化的记录先到这里,日后随着知识的增长会不断补充… 参考链接:https://www.cnblogs.com/Strugglinggirl/p/11011473.html ","date":"2022-03-29","objectID":"/posts/20220329-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:0","tags":["SEO"],"title":"如何进行网站优化","uri":"/posts/20220329-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":["后端篇"],"content":"express搭建服务器跨域问题 解决方案: 设置请求头为\"Access-Control-Allow-Origin\", \"*\" 具体代码 app.all('*', function(req, res, next) { res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With,Content-Type\"); res.header(\"Access-Control-Allow-Credentials\", \"true\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' Express 4.17.1'); res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next(); }); app.use('/api',Router) 记住:解决跨域问题的这个代码必须放在Api调用的前边,否则跨域代码不起作用 ","date":"2022-03-28","objectID":"/posts/20220328-express%E8%B7%A8%E5%9F%9F/:0:1","tags":["JavaScript","Nodejs","Express"],"title":"express跨域","uri":"/posts/20220328-express%E8%B7%A8%E5%9F%9F/"},{"categories":["算法篇"],"content":"今天leetcode上整了两道链表题都用到了递归思想 1.[21. 合并两个有序链表](21. 合并两个有序链表 - 力扣（LeetCode） (leetcode-cn.com)) 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 var mergeTwoLists = function (list1, list2) { if (list1 === null) return list2; if (list2 === null) return list1; if (list1.val \u003c list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1 } else { list2.next = mergeTwoLists(list1, list2.next); return list2 } }; if (list1 === null) return list2; if (list2 === null) return list1; 这两行代码既可以判断首先传入的值也可以结束递归 list1.next = mergeTwoLists(list1.next, list2); 从第一次函数调用开始,当list1链表val小于list2链表的val时,list1这一个节点就是头节点,然后看list1.next,这里list.next作为新的链表传入mergeTowList函数继续判断,一层一层递归下去,直到满足结束递归的条件,开始返回,并且此时开始返回的是一层一层的next,最后形成一个新的链表. 2.[24. 两两交换链表中的节点](24. 两两交换链表中的节点 - 力扣（LeetCode） (leetcode-cn.com)) ","date":"2022-03-09","objectID":"/posts/20220309-%E9%80%92%E5%BD%92%E5%AD%A6%E4%B9%A0/:0:0","tags":["JavaScript"],"title":"递归学习","uri":"/posts/20220309-%E9%80%92%E5%BD%92%E5%AD%A6%E4%B9%A0/"},{"categories":["前端篇"],"content":"主要思想：给对象一个临时函数来调用,调用完毕后删除该临时函数对应的属性 call函数封装 function pliCall(fn, obj, ...args) { if (obj === undefined || obj === null) { obj = globalThis } obj.temp = fn let result = obj.temp(...args) delete obj.temp return result } apply函数 function pliApply(fn, obj, args) { if (obj === undefined || obj === null) { obj = globalThis } obj.temp = fn; let result = obj.temp(...args) delete obj.temp return result } bind函数 function pliBind(fn, obj, ...args) { return function (...args2) { if (obj === undefined || obj === null) { obj = globalThis } obj.temp = fn; let result = obj.temp(...args, ...args2) delete obj.temp; return result } } ","date":"2022-01-06","objectID":"/posts/20220106-%E6%89%8B%E5%86%99call-apply-bind/:0:0","tags":["JavaScript"],"title":"手写call\u0026apply\u0026bind","uri":"/posts/20220106-%E6%89%8B%E5%86%99call-apply-bind/"},{"categories":["前端篇"],"content":"简单了解一下call，apply以及bind的用法 ","date":"2021-11-23","objectID":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/:1:0","tags":["JavaScript"],"title":"call，apply，bind的简单用法","uri":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"},{"categories":["前端篇"],"content":"首先说一下三者的共同之处 call、apply、bind作用是改变函数执行时的上下文，简单地说就是改变函数运行时的this指向，当我们函数中所需要的this指向不是当前的this时可以用这三种方法来改变this指向 ","date":"2021-11-23","objectID":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/:1:1","tags":["JavaScript"],"title":"call，apply，bind的简单用法","uri":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"},{"categories":["前端篇"],"content":"其次来介绍一下这三种方法并说明这三种方法的作用 ","date":"2021-11-23","objectID":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/:1:2","tags":["JavaScript"],"title":"call，apply，bind的简单用法","uri":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"},{"categories":["前端篇"],"content":"call() call(绑定给this的值，，第一个参数，第二个参数) call(this，agr1，arg2) 注意：call（）的传参，每个参数中间用 ,来分割 let obj1 = { name: 'obj1Name', setAge: function (age) { this.age = age } } let obj2 = { name: 'obj2Name' } obj1.setAge(18); console.log(obj1); // {\"name\":\"obj1Name\",\"age\":18} // obj2.setAge(19); // obj2.setAge is not a function console.log(obj2); obj1.setAge.call(obj2, 20); console.log(obj2); // {\"name\":\"obj2Name\",\"age\":20} obj2对象中没有setAge函数当需要用到setAge函数时可以通过call()改变obj1中setAge函数this的指向并传递参数，指向obj2，来给obj2设置age。 ","date":"2021-11-23","objectID":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/:1:3","tags":["JavaScript"],"title":"call，apply，bind的简单用法","uri":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"},{"categories":["前端篇"],"content":"apply() apply(绑定给this的值,[arg1,arg2]) apply(this，[agr1，arg2]) let obj1 = { name: 'obj1Name', setAge: function (age) { this.age = age } } let obj2 = { name: 'obj2Name' } obj1.setAge(18); console.log(obj1); // {\"name\":\"obj1Name\",\"age\":18} // obj2.setAge(19); // obj2.setAge is not a function console.log(obj2); obj1.setAge.apply(obj2, [20]); console.log(obj2); // {\"name\":\"obj2Name\",\"age\":20} apply()和call()的用法相似，唯一的不同点就是使用apply()方法传参时需要把参数传入数组中 ","date":"2021-11-23","objectID":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/:1:4","tags":["JavaScript"],"title":"call，apply，bind的简单用法","uri":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"},{"categories":["前端篇"],"content":"bind() bind(绑定给this的值,arg1,arg2)(arg3) bind(this，agr1，arg2)(arg3) 和call()很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数以及bind接收的参数列表的使用。 function fn(a, b) { return this.f+a+b } console.log(fn.bind({f:2})(1,1)); // 4 console.log(fn.bind({f:2},2)(1)); // 5 ","date":"2021-11-23","objectID":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/:1:5","tags":["JavaScript"],"title":"call，apply，bind的简单用法","uri":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"},{"categories":["前端篇"],"content":"call(),apply(),bind()三种方法的区别 bind()返回对应函数, 便于稍后调用； apply(), call()则是立即调用。 需要注意的时箭头函数的this指向，箭头函数内的this的指向指的是箭头函数所在对象中的this","date":"2021-11-23","objectID":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/:1:6","tags":["JavaScript"],"title":"call，apply，bind的简单用法","uri":"/posts/20211123-callapplybind%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"},{"categories":["前端篇"],"content":"在了解深浅拷贝前需要首先先谈谈拷贝的概念 ","date":"2021-11-22","objectID":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/:0:0","tags":["JavaScript"],"title":"浅拷贝与深拷贝","uri":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"categories":["前端篇"],"content":"拷贝 拷贝就是拷贝指向对象的指针，意思就是说：拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间， ","date":"2021-11-22","objectID":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/:0:1","tags":["JavaScript"],"title":"浅拷贝与深拷贝","uri":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"categories":["前端篇"],"content":"浅拷贝 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址。 ","date":"2021-11-22","objectID":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/:0:2","tags":["JavaScript"],"title":"浅拷贝与深拷贝","uri":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"categories":["前端篇"],"content":"深拷贝 深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。 ","date":"2021-11-22","objectID":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/:0:3","tags":["JavaScript"],"title":"浅拷贝与深拷贝","uri":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"categories":["前端篇"],"content":"浅拷贝的四种方式 1.键值拷贝 let pl={name:'plumli'}; let plum={name:pl.name}; console.log(plum); // {\"name\":\"plumli\"} plum.name='plum'; console.log(pl); // {\"name\":\"plumli\"} console.log(plum); // {\"name\":\"plum\"} 2.for循环拷贝 let pl = { name: 'lyh', url: 'plumli.xyz' }; let obj = {}; for (const key in pl) { obj[key] = pl[key] } obj.name = 'plumli'; console.log(obj); // {\"name\":\"plumli\",\"url\":\"plumli.xyz\"} console.log(pl); // {\"name\":\"lyh\",\"url\":\"plumli.xyz\"} 3.assign方法拷贝 let pl = { name: 'lyh', url: 'plumli.xyz' }; let obj = Object.assign({}, pl) obj.name = 'plumli'; console.log(pl); // {\"name\":\"lyh\",\"url\":\"plumli.xyz\"} console.log(obj); // {\"name\":\"plumli\",\"url\":\"plumli.xyz\"} 4.解构方法拷贝 let pl = { name: 'lyh', url: 'plumli.xyz' }; let obj = { ...pl }; console.log(obj); // {\"name\":\"lyh\",\"url\":\"plumli.xyz\"} ","date":"2021-11-22","objectID":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/:0:4","tags":["JavaScript"],"title":"浅拷贝与深拷贝","uri":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"categories":["前端篇"],"content":"深拷贝方法 当拷贝的对象里面又有新的对象时，此时进行普通方法的拷贝只是拷贝到了新的对象的内存地址，当拷贝的对象内的对象值发生变化时，新拷贝的对象值也会发生变化。此时就需要进行深拷贝。 深拷贝中对象和数组类型本质上都是对象数据类型，如果经过普通深拷贝后对象里数组的数组方法可能不可用，下边先来介绍一下简单版的深拷贝。 简单版 let obj1 = { name: 'obj1name', age: 18, hobbies: { one: 'eat', two: 'sleep' } } function copy(object) { let res = {}; for (const key in object) { res[key] = typeof object[key] === 'object' ? copy(object[key]) : object[key] } return res } let obj2 = copy(obj1); obj2.hobbies.three = 'play'; // 如果 改变obj2内对象的值，obj1内对象的值不变，即为拷贝成功 console.log('obj1', JSON.stringify(obj1, null, 2)); // obj1 { // \"name\": \"obj1name\", // \"age\": 18, // \"hobbies\": { // \"one\": \"eat\", // \"two\": \"sleep\" // } console.log('obj2', JSON.stringify(obj2, null, 2)); // obj2 { // \"name\": \"obj1name\", // \"age\": 18, // \"hobbies\": { // \"one\": \"eat\", // \"two\": \"sleep\", // \"three\": \"play\" // } // } 简单般的深拷贝方法无法拷贝数组对象，现在来看升级版 升级版 介绍：Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。 let obj1 = { name: 'obj1name', age: 18, hobbies: { one: 'eat', two: 'sleep' }, lessons: ['javascript', 'css'] } function copy(object) { let res = object instanceof Array ? [] : {}; for (const [k, v] of Object.entries(object)) { res[k] = typeof v === 'object' ? copy(v) : v } return res } let obj2 = copy(obj1); obj2.hobbies.three = 'play'; obj2.lessons.push('html'); console.log('obj1', JSON.stringify(obj1, null, 2)); // obj1 { // \"name\": \"obj1name\", // \"age\": 18, // \"hobbies\": { // \"one\": \"eat\", // \"two\": \"sleep\" // }, // \"lessons\": [ // \"javascript\", // \"css\" // ] // } console.log('obj2', JSON.stringify(obj2, null, 2)); // obj2 { // \"name\": \"obj1name\", // \"age\": 18, // \"hobbies\": { // \"one\": \"eat\", // \"two\": \"sleep\", // \"three\": \"play\" // }, // \"lessons\": [ // \"javascript\", // \"css\", // \"html\" // ] // } 以上为本阶段学习拷贝的一点理解，以后若接触到更多会逐步添加… ","date":"2021-11-22","objectID":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/:0:5","tags":["JavaScript"],"title":"浅拷贝与深拷贝","uri":"/posts/20211122-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"categories":["前端篇"],"content":"判断浏览器滚动条是否到达浏览器底部在判断前是需要了解几个关键词 滚动条到顶部的距离 scrollTop 当前窗口内容的可视区 windowHeight 滚动条内容的总高度 scrollHeight 判断到底部的等式是：scrollTop+windowHeight=scrollHeight 具体代码如下： window.onscroll = function () { //变量scrollTop是滚动条滚动时，距离顶部的距离 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //变量windowHeight是可视区的高度 var windowHeight = document.documentElement.clientHeight || document.body.clientHeight; //变量scrollHeight是滚动条的总高度 var scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight; //滚动条到底部的条件 if (scrollTop + windowHeight == scrollHeight) { //写后台加载数据的函数 console.log( \"距顶部\" scrollTop +\"可视区高度\" +windowHeight +\"滚动条总高度\" +scrollHeight ); } }; ","date":"2021-11-05","objectID":"/posts/20211105-js%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%98%AF%E5%90%A6%E5%88%B0%E5%BA%95%E9%83%A8/:0:0","tags":["JavaScript"],"title":"Js判断浏览器进度条是否到底部","uri":"/posts/20211105-js%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%98%AF%E5%90%A6%E5%88%B0%E5%BA%95%E9%83%A8/"},{"categories":["前端篇"],"content":"// 发生什么？ let config = { alert: setInterval(()=\u003e{ console.log('Alert!') }，1000) } config = null A：setInterval 的回调不会被调用 B：setInterval 的回调会被调用一次 C：setInterval 的回调会被每秒钟调用 D：我们从没调用过config.alert()，config为null 解析： 答案：C 一般情况下当我们将对象赋值为null，那些对象会被进行垃圾回收（garbage collected）因为已经没有对这些对象的引用了，然而，setInterval的参数是一个箭头函数（所以上下文绑定到对象config了），回调函数仍然保留着对config的引用，只要存在引用，对象就不会被垃圾回收，因为没有被垃圾回收，setInterval的回调每1000ms会被调用一次 ","date":"2021-10-09","objectID":"/posts/20211009-js%E9%97%AE%E9%A2%982%E5%AE%9A%E6%97%B6%E5%99%A8/:0:0","tags":["JavaScript"],"title":"JsQuestions-2_定时器","uri":"/posts/20211009-js%E9%97%AE%E9%A2%982%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"categories":["前端篇"],"content":"使对象按照某个顺序排序 当前属性值相同时按照另一个属性排序 let obj=[ {name:'zhangsan',age:20,score:89}, {name:'zhaoli',age:20,score:90}, {name:'lisi',age:21,score:86}, {name:'wangwu',age:23,score:95}, ] function rank(attr1,attr2) { return function (a,b) { if (a[attr1]==b[attr1]) return a[attr2]-b[attr2]; return a[attr1]-b[attr1]; } } obj.sort(rank('age')); console.log(obj.sort(rank('age','score'))); ","date":"2021-08-17","objectID":"/posts/20210817-%E5%AF%B9%E8%B1%A1%E6%8C%89%E7%85%A7%E6%9F%90%E4%B8%80%E5%B1%9E%E6%80%A7%E6%8E%92%E5%BA%8F/:0:0","tags":["JavaScript"],"title":"对象按照某一属性排序","uri":"/posts/20210817-%E5%AF%B9%E8%B1%A1%E6%8C%89%E7%85%A7%E6%9F%90%E4%B8%80%E5%B1%9E%E6%80%A7%E6%8E%92%E5%BA%8F/"},{"categories":["前端篇"],"content":"​ 最近在做vue项目时遇到了报错 ​ Duplicate keys detected: ‘[object Object]’. This may cause an update error. ​ 由于这个问题是第一次遇见，所以在解决起来废了点时间 ​ ![1](E:\\Blog_Github\\Plumliil\\source_posts\\vue报错解决Duplicate keys detected[object Object]\\1.png) 解决：在遍历数组时 :key书写错误， ​ 我的错误写法 \u003cul\u003e \u003cli v-for=\"v in caseintrocon\" :key=\"i\"\u003e \u003cp\u003e\u003cem\u003e{{v.data_m_d}}\u003c/em\u003e{{v.data_y}}\u003c/p\u003e \u003cp\u003e\u003cstrong\u003e{{v.title}}\u003c/strong\u003e\u003c/p\u003e \u003cp\u003e{{v.text_con}}\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e 改正后的写法： ​ \u003cul\u003e \u003cli v-for=\"(v,i) in caseintrocon\" :key=\"i\"\u003e \u003cp\u003e\u003cem\u003e{{v.data_m_d}}\u003c/em\u003e{{v.data_y}}\u003c/p\u003e \u003cp\u003e\u003cstrong\u003e{{v.title}}\u003c/strong\u003e\u003c/p\u003e \u003cp\u003e{{v.text_con}}\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e 总结：平时用修改前的方式写代码也没有出错，这次代码出错给了我个提醒，以后书写代码要更加规范 ","date":"2021-08-16","objectID":"/posts/20210616-vue%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3duplicate-keys-detected-object-object/:0:0","tags":["Vue","踩坑记录"],"title":"vue报错解决Duplicate keys detected:[object Object]","uri":"/posts/20210616-vue%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3duplicate-keys-detected-object-object/"},{"categories":["前端篇"],"content":"\u003ctemplate\u003e \u003cp :class=\"{ 'isActive': flag }\"\u003e文本一\u003c/p\u003e \u003cp :class=\"['activeA', 'activeB']\"\u003e文本二\u003c/p\u003e \u003cp :class=\"['activeA', 'activeB', { activeC: flag }]\"\u003e文本三\u003c/p\u003e \u003c/template\u003e \u003cscript setup\u003e import { ref } from 'vue' const flag=ref(true); \u003c/script\u003e ","date":"2021-08-15","objectID":"/posts/20210815-vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%B1%BB%E5%90%8D/:0:0","tags":["Vue"],"title":"vue动态绑定类名","uri":"/posts/20210815-vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%B1%BB%E5%90%8D/"},{"categories":["前端篇"],"content":"Ajax应用场景 1.页面上拉加载更多数据 2.列表数据无刷新分页 3.表单项离开焦点数据验证 4.搜索框提示文字下拉列表 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:1:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"Ajax运行环境 Ajax技术需要运行在网站环境下才会生效，可用Node创建的服务器作为网站服务器 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:2:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"Ajax运行原理 普通 浏览器端——-请求——-\u003e服务器端 浏览器端\u003c——响应——-服务器端 ​ 开发人员不可控 ajax 浏览器端——– 创建——-\u003eAjax——-请求——-\u003e服务器端 浏览器端\u003c——– 响应——Ajax\u003c——-响应——-服务器端 ​ 开发人员可控 ajax相当于浏览器发送请求与接收响应的代理人，以实现不影响用户浏览页面的情况下局部更新页面数据，从而提高用户体验 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:3:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"Ajax实现步骤(需重启服务器) 1.创建Ajax对象 var xhr=new XMLHttpPequest() 创建ajax对象httprequest使用http请求，返回xml文件 现在在ajax请求中一般服务器端一般返回json数据 2.告诉Ajax请求地址及请求方式 xhr.open('get','http://www.example.com'); open方法，第一个参数为请求方式，第二个参数是请求地址 3.发送请求 xhr.send() 4.获取服务器端给与客户端的响应数据 xhr.onload=function(){console.log(xhr.requestseText);} ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:4:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"服务器端响应的数据格式 在真实的项目中，服务器端*大部分情况下会以json对象作为响应数据的格式，*当客户端拿到数据时，要将json数据和html字符串进行拼接，然后将拼接的结果展示在页面上 在http请求与响应的过程中，无论是请求参数还是相应内容，如果是对象类型，最终都会被转化成对象字符串进行传输 JSON.parse()// 将字符串转化为json对象 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:5:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"请求参数传递 传统网站表单提交 \u003cform method=\"get\" action=\"http://www.example.com\"\u003e \u003cinput type=\"text\" name=\"username\"\u003e \u003cinput type=\"password\" name=\"password\"\u003e \u003c/form\u003e Get请求方式 xhr.open('get','http://www.example.com'); Post请求方式 xhr.setRequestHeader('Content-Type','applicate/x-www-form-urlencoded') xhr.send('name=zhangsan\u0026age=20') 请求报文 在HTTP请求和响应的过程中传递的数据就是叫报文，包括要传送的数据和一些附加信息，这些数据和信息要遵循规定好的格式 客户端发送请求报文，请求方式和请求地址，服务器进行响应 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:6:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"请求参数的格式 1.application/x-www-form-urlencoded name=zhangsan\u0026sex=男 2.application/json {name:'zhangsan',age:'20',sex:'男'} 在请求头中指定Content-type属性的值是application/json,告诉服务器当前请求参数的格式是json JSON.stringify()//将json对象转化为json字符串 Get请求是不能提交json对象数据格式的，传统网站的表单提交也是不支持json对象数据格式的 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:7:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"获取服务器端响应 Ajax状态码 在创建ajax对象，配置ajax对象，发送请求，一级接收完服务器端响应数据，这个过程中的每一步骤都会对应一个数值，这个数值就是ajax状态码。 0：请求未初始化（还没有调用open） 1：请求已经建立，但是还没有发送（还没有调用send） 2：请求已发送 3：请求正在处理中，通常响应中已经有部分数据可以用了 4：响应已完成，可以获取并使用服务器的响应 xhr.readyState // 获取ajax状态码 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:8:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"获取服务器端的响应 onreadystatechange事件 当Ajax状态码发生变化时将自动触发该事件 区别描述 onload事件 onreadystatuschange事件 是否兼容IE低版本 不兼容 兼容 是否需要判断Ajax状态码 不需要 需要 被调用次数 一次 多次 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:9:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"Ajax错误处理 1.网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期的结果 可判断服务器返回的状态码，粉别进行处理。xhr.status获取http状态码 2.网络畅通，服务器端没有收到请求，返回404状态码 检查请求地址是否错误 3.网络通常，服务器能收到请求，服务器端返回500状态码 4.网络中断，请求无法发送到服务器 会触发xhr对象下面的onerror事件，再onerror事件处理函数中对错误进行处理 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:10:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"状态码区分 Ajax状态码：表示Ajax请求的过程状态 ajax对象返回 HTTP状态码：表示请求的处理结果 是服务器端返回的 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:11:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"低版本IE浏览器的缓存问题 在低版本的IE浏览器中，Ajax请求有严重的缓存问题，即在请求地址不会发生变化的情况下，只有第一次请求会真正的发送到服务器端，后续的请求会从浏览器的缓存中获取结果，即使服务器端数据更新了，客户端还是拿到的是缓存中的旧数据 解决方案：在请求地址后面加请求参数，保证每一次请求中的请求参数的值不同 xhr.open('get','http://www.example.com?t='+Math.random()) ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:12:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"同步异步概述 同步：一个人同一时间只能做同一件事情，只有一件事情做完后，才能做另外一件事情 console.log('before') console.log('after') 异步：一个人一件事情做了一半，转而去做另一件事情，当其他事情做完后，再回过头来继续做之前未完成的事情 异步代码虽然需要花时间去执行，但是程序不会等待异步代码执行后再继续执行后续代码，而是直接执行后续代码，当后续代码执行完后再回头看异步代码是否返回结果，如果已有返回结果，再调用事先准备好的回调函数处理异步代码执行结果 console.log('before'); setTimeout(()=\u003e{console.log('last)},2000) console.log('after'); ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:13:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"Ajax封装 问题：发送一次请求代码过多，发送请求代码冗余重复 解决方案：将请求代码封装到函数中，发请求是调用函数即可。 ","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:14:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"请求参数要考虑的问题： 1.请求参数位置的问题 将请求参数传递到ajax内部，在函数内部根据请求方式的不同请求参数放置在不同的位置 get 放在请求地址的后面 post 放在send方法中 2.请求参数的格式问题 application/x-www-form-urlencoded 参数名称=参数值\u0026参数名称==参数值 application/json {name:'zhangsan',age:20} 传递对象数据类型对于函数调用者更加友好 在函数内部对象数据类型转换为字符串","date":"2021-08-15","objectID":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/:15:0","tags":["Ajax","JavaScript"],"title":"认识Ajax","uri":"/posts/20210815-%E8%AE%A4%E8%AF%86ajax/"},{"categories":["前端篇"],"content":"ajax({ url:'http://localhost:3000/xxx', data:{ name:'zhangsan', age:20 }, success:function (data){ console.log(data) } }) function ajax(options){ // 存储默认值 var defaults={ type: 'get', url:'', data:{}, header:{ 'Content-Type':'application/x-www-form-urlencoded' }, success:function (){}, error:function (){} } // 使用options对象中的属性覆盖defaults中的属性 Object.assign(defaults,options) // 创建ajax对象 var xhr=new XMLHttpRequest(); // 拼接请求参数的对象 var params=''; // 循环用户传递过来的对象格式参数 for(var attr in defaults.data){ params+=attr+'='+defaults.data[attr]+'\u0026'; } \u003c!--more--\u003e // 参数后边的\u0026截取掉 params=params.substr(0,params.length-1); // 判断请求方式 if(defaults.type=='get'){ defaults.url=defaults.url+'?'+params; } // 配置ajax对象 xhr.open(defaults.type,defaults.url) if(defaults.type=='post'){ var contentType=defaults.header['Content-Type']; xhr.setRequestHeader('Content-Type',contentType); // 判断用户希望的请求参数格式类型 // 如果类型为json if(contentType=='application/json'){ // 传递json类型的参数 xhr.send(JSON.stringify(defaults.data)) }else{ // 传递普通类型的参数 xhr.send(params); } }else{ xhr.send(); } xhr.onload=()=\u003e{ // xhr.getResponseHeader(); // 获取响应头数据 var contentType=xhr.getResponseHeader('Content-Type'); var responseText=xhr.responseText; // 如果响应中包含application/json if(contentType.includes('application/json')){ // json字符串转化为json对象 responseText=JSON.parse(responseText); } // 当http状态码等于200时 if (xhr.status==200){ // 请求成功 defaults.success(responseText,xhr); }else { // 请求失败 defaults.error(responseText,xhr); } } } ","date":"2021-08-15","objectID":"/posts/20210815-ajax%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85/:0:0","tags":["Ajax","JavaScript"],"title":"Ajax函数封装","uri":"/posts/20210815-ajax%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85/"},{"categories":["前端篇"],"content":"elementui使用中deep的用法/deep/ 在做第一个vue项目时遇到了一个问题，在使用elementui中的Drawer（抽屉组件时），想要修改Drawer的标题，尝试着修改title的样式，但没有效果，尝试了很多方法，最后用/deep/解决了问题 通过深度选择 .el-drawer 中的title即可修改标题样式成功 /deep/ .el-drawer__header{ color: white; } 在此之后可以用/deep/来修改elementui中一些其他组件的样式 ","date":"2021-08-05","objectID":"/posts/20210805-vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AE%A4%E8%AF%86deep/:0:0","tags":["Vue"],"title":"Vue学习之认识/deep/","uri":"/posts/20210805-vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AE%A4%E8%AF%86deep/"},{"categories":["前端篇"],"content":"ref相当于一个dom节点，值为string 通俗将类似于原生js的document.querySelector(‘xxx’)；但是不同的是vue是操纵虚拟dom，在渲染初期并没有这个属性，而是在创建vue实例后才加到虚拟dom中。 其中ref有以下几种常见用法： 本页面获取dom元素 \u003cdiv ref=\"divmsg\"\u003edivmsg\u003c/div\u003e \u003cbutton @click=\"getmsg\"\u003ediv内元素\u003c/button\u003e getmsg(){ console.log(this.$ref.divmsg) } // 输出11111 获取子组件中的data 子组件 \u003cdiv\u003e{{msg}}\u003c/div\u003e ------------------ data(){ return{ msg:'hello world！' } } 父组件 \u003cdiv id=\"app\"\u003e \u003cChild ref=\"child\"\u003e\u003c/Child\u003e \u003cbutton @click=\"getChild\"\u003e获取子组件中值\u003c/button\u003e \u003c/div\u003e --------------------------------- import xxx from xxx methods:{ getchild(){ console.log(this.$ref.child.msg); } } // 输出：hello world! 调用子组件中方法 子组件 \u003cdiv\u003e\u003c/div\u003e ---------------------- methods:{ childMethod(){ console.log('childMethod'); } } 父组件 \u003cdiv id=\"app\"\u003e \u003cChild ref=\"child\"\u003e\u003c/Child\u003e \u003cbutton @click=\"getChild\"\u003e调用子组件方法\u003c/button\u003e \u003c/div\u003e --------------------------------- import xxx from xxx methods:{ getchild(){ console.log(this.$ref.child.childMethod()); } } // 输出：hello world! 其中$ref是一个对象，存放已注册过ref的所有子组件 通过vue实例.$refs.属性名即可获取标记的元素 如果ref重名后面的会把前面的覆盖 其中若元素使用v-for则返回dom节点数组 ","date":"2021-08-04","objectID":"/posts/20210804-vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AE%A4%E8%AF%86ref/:0:0","tags":["Vue"],"title":"Vue学习之认识ref","uri":"/posts/20210804-vue%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AE%A4%E8%AF%86ref/"},{"categories":["前端篇"],"content":"资源事件 事件名称 何时触发 error 资源加载失败时。 abort 正在加载资源已经被中止时。 load 资源及其相关资源已完成加载。 beforeunload window，document 及其资源即将被卸载。 unload 文档或一个依赖资源正在被卸载。 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:1","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"网络事件 事件名称 何时触发 online 浏览器已获得网络访问。 offline 浏览器已失去网络访问。 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:2","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"焦点事件 事件名称 何时触发 focus 元素获得焦点（不会冒泡）。 blur 元素失去焦点（不会冒泡）。 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:3","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"WebSocket 事件 事件名称 何时触发 open WebSocket 连接已建立。 message 通过 WebSocket 接收到一条消息。 error WebSocket 连接异常被关闭（比如有些数据无法发送）。 close WebSocket 连接已关闭。 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:4","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"会话历史事件 事件名称 何时触发 pagehide A session history entry is being traversed from. pageshow A session history entry is being traversed to. popstate A session history entry is being navigated to (in certain cases). ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:5","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"CSS 动画事件 事件名称 何时触发 animationstart 某个 CSS 动画开始时触发。 animationend 某个 CSS 动画完成时触发。 animationiteration 某个 CSS 动画完成后重新开始时触发。 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:6","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"CSS 过渡事件 事件名称 何时触发 transitionstart A CSS transition has actually started (fired after any delay). transitioncancel A CSS transition has been cancelled. transitionend A CSS transition has completed. transitionrun A CSS transition has begun running (fired before any delay starts). ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:7","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"表单事件 事件名称 何时触发 reset 点击重置按钮时 submit 点击提交按钮 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:8","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"打印事件 时间名称 何时触发 beforeprint 打印机已经就绪时触发 afterprint 打印机关闭时触发 文本写作事件 Event Name Fired When compositionstart The composition of a passage of text is prepared (similar to keydown for a keyboard input, but works with other inputs such as speech recognition). compositionupdate A character is added to a passage of text being composed. compositionend The composition of a passage of text has been completed or canceled. ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:9","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"视图事件 Event Name Fired When fullscreenchange An element was turned to fullscreen mode or back to normal mode. fullscreenerror It was impossible to switch to fullscreen mode for technical reasons or because the permission was denied. resize The document view has been resized. scroll The document view or an element has been scrolled. ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:10","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"剪贴板事件 Event Name Fired When cut 已经剪贴选中的文本内容并且复制到了剪贴板。 copy 已经把选中的文本内容复制到了剪贴板。 paste 从剪贴板复制的文本内容被粘贴。 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:11","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"键盘事件 Event Name Fired When keydown 按下任意按键。 keypress 除 Shift、Fn、CapsLock 外的任意键被按住。（连续触发。） keyup 释放任意按键。 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:12","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"鼠标事件 Event Name Fired When auxclick A pointing device button (ANY non-primary button) has been pressed and released on an element. click 在元素上按下并释放任意鼠标按键。 contextmenu 右键点击（在右键菜单显示前触发）。 dblclick 在元素上双击鼠标按钮。 mousedown 在元素上按下任意鼠标按钮。 mouseenter 指针移到有事件监听的元素内。 mouseleave 指针移出元素范围外（不冒泡）。 mousemove 指针在元素内移动时持续触发。 mouseover 指针移到有事件监听的元素或者它的子元素内。 mouseout 指针移出元素，或者移到它的子元素上。 mouseup 在元素上释放任意鼠标按键。 pointerlockchange 鼠标被锁定或者解除锁定发生时。 pointerlockerror 可能因为一些技术的原因鼠标锁定被禁止时。 select 有文本被选中。 wheel 滚轮向任意方向滚动。 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:13","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"拖放事件 Event Name Fired When drag 正在拖动元素或文本选区（在此过程中持续触发，每 350ms 触发一次） dragend 拖放操作结束。（松开鼠标按钮或按下 Esc 键） dragenter 被拖动的元素或文本选区移入有效释放目标区 dragstart 用户开始拖动HTML元素或选中的文本 dragleave 被拖动的元素或文本选区移出有效释放目标区 dragover 被拖动的元素或文本选区正在有效释放目标上被拖动 （在此过程中持续触发，每350ms触发一次） drop 元素在有效释放目标区上释放 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:14","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"媒体事件 Event Name Fired When audioprocess The input buffer of a ScriptProcessorNode is ready to be processed. canplay The browser can play the media, but estimates that not enough data has been loaded to play the media up to its end without having to stop for further buffering of content. canplaythrough The browser estimates it can play the media up to its end without stopping for content buffering. complete The rendering of an OfflineAudioContext is terminated. durationchange The duration attribute has been updated. emptied The media has become empty; for example, this event is sent if the media has already been loaded (or partially loaded), and the load() method is called to reload it. ended Playback has stopped because the end of the media was reached. loadeddata The first frame of the media has finished loading. loadedmetadata The metadata has been loaded. pause Playback has been paused. play Playback has begun. playing Playback is ready to start after having been paused or delayed due to lack of data. ratechange The playback rate has changed. seeked A seek operation completed. seeking A seek operation began. stalled The user agent is trying to fetch media data, but data is unexpectedly not forthcoming. suspend Media data loading has been suspended. timeupdate The time indicated by the currentTime attribute has been updated. volumechange The volume has changed. waiting Playback has stopped because of a temporary lack of data. ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:15","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"进度事件 Event Name Fired When abort Progression has been terminated (not due to an error). error Progression has failed. load Progression has been successful. loadend Progress has stopped (after “error”, “abort” or “load” have been dispatched). loadstart Progress has begun. progress In progress. timeout Progression is terminated due to preset time expiring. ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:16","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"存储事件 change` (see [Non-standard events](https://developer.mozilla.org/zh-CN/docs/Web/Events#Non-standard_events)) `storage ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:17","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"更新事件 checking` `downloading` `error` `noupdate` `obsolete` `updateready ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:18","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"值变化事件 broadcast` `CheckboxStateChange` `hashchange` `input` `RadioStateChange` `readystatechange` `ValueChange ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:19","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"未分类的事件 invalid` `message` `message` `open` `show ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:20","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"不常见和非标准事件 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:21","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"Abortable Fetch events Event name Fired when abort A DOM request is aborted, i.e. using AbortController.abort(). ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:22","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"WebVR events Event name Fired when vrdisplayactivate When a VR display is able to be presented to, for example if an HMD has been moved to bring it out of standby, or woken up by being put on. vrdisplayblur when presentation to a VRDisplay has been paused for some reason by the browser, OS, or VR hardware — for example, while the user is interacting with a system menu or browser, to prevent tracking or loss of experience. vrdisplayconnect when a compatible VRDisplay is connected to the computer. vrdisplaydeactivate When a VRDisplay can no longer be presented to, for example if an HMD has gone into standby or sleep mode due to a period of inactivity. vrdisplaydisconnect When a compatible VRDisplay is disconnected from the computer. vrdisplayfocus When presentation to a VRDisplay has resumed after being blurred. vrdisplaypresentchange The presenting state of a VRDisplay changes — i.e. goes from presenting to not presenting, or vice versa. ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:23","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"SVG 事件 SVGAbort` `SVGError` `SVGLoad` `SVGResize` `SVGScroll` `SVGUnload` `SVGZoom ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:24","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"数据库事件 abort` `blocked` `complete` `error` `success` `upgradeneeded` `versionchange ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:25","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"脚本事件 afterscriptexecute` `beforescriptexecute ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:26","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"菜单事件 DOMMenuItemActive` `DOMMenuItemInactive ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:27","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"窗口事件 close ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:28","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"弹出事件 popuphidden` `popuphiding` `popupshowing` `popupshown ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:29","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"Tab 事件 visibilitychange ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:30","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"电池事件 chargingchange` `chargingtimechange` `dischargingtimechange` `levelchange ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:31","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"呼叫事件 alerting` `busy` `callschanged` `cfstatechange` `connected` `connecting` `dialing` `disconnected` `disconnecting` `error` `held`, `holding` `incoming` `resuming` `statechange` `voicechange ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:32","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"传感器事件 compassneedscalibration` `devicemotion` `deviceorientation` `orientationchange ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:33","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"智能卡事件 icccardlockerror` `iccinfochange` `smartcard-insert` `smartcard-remove` `stkcommand` `stksessionend` `cardstatechange ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:34","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"短信和USSD事件 delivered` `received` `sent` `ussdreceived ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:35","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"帧事件 mozbrowserclose` `mozbrowsercontextmenu` `mozbrowsererror` `mozbrowsericonchange` `mozbrowserlocationchange` `mozbrowserloadend` `mozbrowserloadstart` `mozbrowseropenwindow` `mozbrowsersecuritychange` `mozbrowsershowmodalprompt` `mozbrowsertitlechange ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:36","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"DOM变异事件 DOMAttributeNameChanged` `DOMAttrModified` `DOMCharacterDataModified` `DOMContentLoaded` `DOMElementNameChanged` `DOMNodeInserted` `DOMNodeInsertedIntoDocument` `DOMNodeRemoved` `DOMNodeRemovedFromDocument` `DOMSubtreeModified ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:37","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"触摸事件 touchcancel` `touchend` `touchmove` `touchstart ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:38","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"指针事件 pointerover` `pointerenter` `pointerdown` `pointermove` `pointerup` `pointercancel` `pointerout` `pointerleave` `gotpointercapture` `lostpointercapture ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:39","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"标准事件 这些事件在官方Web规范中定义，并且应在各个浏览器中通用。 每个事件都和代表事件接收方的对象（由此您可以查到每个事件提供的数据），定义这个事件的标准或标准链接会一起列出。 事件名称 事件类型 规范 触发时机… abort UIEvent DOM L3 资源载入已被中止 abort ProgressEvent ProgressandXMLHttpRequest Progress被终止(不是error造成的) abort Event IndexedDB 事务已被中止 afterprint Event HTML5 相关文档已开始打印或打印预览已被关闭 animationcancel AnimationEvent CSS Animations A CSS animation has aborted. animationend AnimationEvent CSS Animations 完成一个CSS 动画 animationiteration AnimationEvent CSS Animations 重复播放一个CSS 动画 animationstart AnimationEvent CSS Animations 一个 CSS 动画已开始 appinstalled Event Web App Manifest A web application is successfully installed as a progressive web app. audioprocess AudioProcessingEvent Web Audio API audioprocess 一个ScriptProcessorNode 的输入缓冲区可处理 audioend Event Web Speech API 用户代理捕捉到用以语音识别的音频 audiostart Event Web Speech API 用户代理开始捕捉用以语音识别的音频 beforeprint Event HTML5 相关文档将要开始打印或准备打印预览 beforeunload BeforeUnloadEvent HTML5 即将卸载 window，document 及其资源 beginEvent TimeEvent SVG A SMIL animation element begins. blocked IndexedDB An open connection to a database is blocking a versionchange transaction on the same database. blur FocusEvent DOM L3 An element has lost focus (does not bubble). boundary SpeechSynthesisEvent Web Speech API The spoken utterance reaches a word or sentence boundary canplay Event HTML5 media The user agent can play the media, but estimates that not enough data has been loaded to play the media up to its end without having to stop for further buffering of content. canplaythrough Event HTML5 media The user agent can play the media up to its end without having to stop for further buffering of content. change Event DOM L2, HTML5 The change event is fired for ](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input), [, and `` elements when a change to the element’s value is committed by the user. chargingchange Event Battery status The battery begins or stops charging. chargingtimechange Event Battery status The chargingTime attribute has been updated. click MouseEvent DOM L3 A pointing device button has been pressed and released on an element. close Event WebSocket A WebSocket connection has been closed. complete IndexedDB A transaction successfully completed. complete OfflineAudioCompletionEvent Web Audio API OfflineAudioCompletionEvent The rendering of an OfflineAudioContext is terminated. compositionend CompositionEvent DOM L3 The composition of a passage of text has been completed or canceled. compositionstart CompositionEvent DOM L3 The composition of a passage of text is prepared (similar to keydown for a keyboard input, but works with other inputs such as speech recognition). compositionupdate CompositionEvent DOM L3 A character is added to a passage of text being composed. contextmenu MouseEvent HTML5 The right button of the mouse is clicked (before the context menu is displayed). copy ClipboardEvent Clipboard The text selection has been added to the clipboard. cut ClipboardEvent Clipboard The text selection has been removed from the document and added to the clipboard. dblclick MouseEvent DOM L3 A pointing device button is clicked twice on an element. devicechange Event Media Capture and Streams A media device such as a camera, microphone, or speaker is connected or removed from the system. devicemotion DeviceMotionEvent Device Orientation Events Fresh data is available from a motion sensor. deviceorientation DeviceOrientationEvent Device Orientation Events Fresh data is available from an orientation sensor. dischargingtimechange Event Battery status The dischargingTime attribute has been updated. DOMActivate UIEvent DOM L3 A button, link or state changing element is activated (use click instead). DOMAttributeNameChanged MutationNameEvent DOM L3 Removed The name of an attribute changed (use mutation observers instead). DOMAttrModified MutationEvent DOM L3 The value of an attribute has been modified (use mutation observers instead). DOMCharacterDataModified MutationEvent DOM L3 A text or another CharacterData has changed (use m","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:40","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"非标准事件 Event Name Event Type Specification Fired when… afterscriptexecute Event Mozilla Specific A script has been executed. beforescriptexecute Event Mozilla Specific A script is about to be executed. beforeinstallprompt Event Chrome specific A user is prompted to save a web site to a home screen on mobile. cardstatechange Firefox OS specific The MozMobileConnection.cardState property changes value. change DeviceStorageChangeEvent Firefox OS specific This event is triggered each time a file is created, modified or deleted on a given storage area. connectionInfoUpdate Firefox OS specific The informations about the signal strength and the link speed have been updated. cfstatechange Firefox OS specific The call forwarding state changes. datachange Firefox OS specific The MozMobileConnection.data object changes values. dataerror Firefox OS specific The MozMobileConnection.data object receive an error from the RIL. DOMMouseScroll Mozilla specific The wheel button of a pointing device is rotated (detail attribute is a number of lines). (use wheel instead) dragdrop DragEvent Mozilla specific An element is dropped (use drop instead). dragexit DragEvent Mozilla specific A drag operation is being ended(use dragend instead). draggesture DragEvent Mozilla specific The user starts dragging an element or text selection (use dragstart instead). icccardlockerror Firefox OS specific the MozMobileConnection.unlockCardLock() or MozMobileConnection.setCardLock() methods fails. iccinfochange Firefox OS specific The MozMobileConnection.iccInfo object changes. localized Mozilla Specific The page has been localized using data-l10n-* attributes. mousewheel IE invented The wheel button of a pointing device is rotated. MozAudioAvailable Event Mozilla specific The audio buffer is full and the corresponding raw samples are available. MozBeforeResize Mozilla specific A window is about to be resized. mozbrowseractivitydone Firefox OS Browser API-specific Sent when some activity has been completed (complete description TBD.) mozbrowserasyncscroll Firefox OS Browser API-specific Sent when the scroll position within a browser `` changes. mozbrowseraudioplaybackchange Firefox OS Browser API-specific Sent when audio starts or stops playing within the browser `` content. mozbrowsercaretstatechanged Firefox OS Browser API-specific Sent when the text selected inside the browser `` content changes. mozbrowserclose Firefox OS Browser API-specific Sent when window.close() is called within a browser ``. mozbrowsercontextmenu Firefox OS Browser API-specific Sent when a browser `` try to open a context menu. mozbrowserdocumentfirstpaint Firefox OS Browser API-specific Sent when a new paint occurs on any document in the browser ``. mozbrowsererror Firefox OS Browser API-specific Sent when an error occured while trying to load a content within a browser iframe mozbrowserfindchange Firefox OS Browser API-specific Sent when a search operation is performed on the browser `` content (see HTMLIFrameElement search methods.) mozbrowserfirstpaint Firefox OS Browser API-specific Sent when the `` paints content for the first time (this doesn’t include the initial paint from about:blank.) mozbrowsericonchange Firefox OS Browser API-specific Sent when the favicon of a browser iframe changes. mozbrowserlocationchange Firefox OS Browser API-specific Sent when an browser iframe’s location changes. mozbrowserloadend Firefox OS Browser API-specific Sent when the browser iframe has finished loading all its assets. mozbrowserloadstart Firefox OS Browser API-specific Sent when the browser iframe starts to load a new page. mozbrowsermanifestchange Firefox OS Browser API-specific Sent when a the path to the app manifest changes, in the case of a browser `` with an open web app embedded in it. mozbrowsermetachange Firefox OS Browser API-specific Sent when a ](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta) elelment is added to, removed from or changed in the browser [’s content. ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:41","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"Mozilla 特定事件 注意：这些事件不会暴露给 Web 内容使用，只能在 chrome 内容的上下文中使用。 ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:42","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"XUL 事件 Event Name Event Type Specification Fired when… broadcast XUL An observer noticed a change to the attributes of a watched broadcaster. CheckboxStateChange XUL The state of a checkbox has been changed either by a user action or by a script (useful for accessibility). close XUL The close button of the window has been clicked. command XUL An element has been activated. commandupdate XUL A command update occurred on a commandset element. DOMMenuItemActive XUL A menu or menuitem has been hovered or highlighted. DOMMenuItemInactive XUL A menu or menuitem is no longer hovered or highlighted. popuphidden PopupEvent XUL A menupopup, panel or tooltip has been hidden. popuphiding PopupEvent XUL A menupopup, panel or tooltip is about to be hidden. popupshowing PopupEvent XUL A menupopup, panel or tooltip is about to become visible. popupshown PopupEvent XUL A menupopup, panel or tooltip has become visible. RadioStateChange XUL The state of a radio has been changed either by a user action or by a script (useful for accessibility). ValueChange XUL The value of an element has changed (a progress bar for example, useful for accessibility). ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:43","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"附加组件特定事件 Event Name Event Type Specification Fired when… MozSwipeGesture Addons specific A touch point is swiped across the touch surface MozMagnifyGestureStart Addons specific Two touch points start to move away from each other. MozMagnifyGestureUpdate Addons specific Two touch points move away from each other (after a MozMagnifyGestureStart). MozMagnifyGesture Addons specific Two touch points moved away from each other (after a sequence of MozMagnifyGestureUpdate). MozRotateGestureStart Addons specific Two touch points start to rotate around a point. MozRotateGestureUpdate Addons specific Two touch points rotate around a point (after a MozRotateGestureStart). MozRotateGesture Addons specific Two touch points rotate around a point (after a sequence of MozRotateGestureUpdate). MozTapGesture Addons specific Two touch points are tapped on the touch surface. MozPressTapGesture Addons specific A “press-tap” gesture happened on the touch surface (first finger down, second finger down, second finger up, first finger up). MozEdgeUIGesture Addons specific A touch point is swiped across the touch surface to invoke the edge UI (Win8 only). MozAfterPaint Addons specific Content has been repainted. DOMPopupBlocked Addons specific A popup has been blocked DOMWindowCreated Addons specific A window has been created. DOMWindowClose Addons specific A window is about to be closed. DOMTitleChanged Addons specifc The title of a window has changed. DOMLinkAdded Addons specifc A link has been added a document. DOMLinkRemoved Addons specifc A link has been removed inside from a document. DOMMetaAdded Addons specific A meta element has been added to a document. DOMMetaRemoved Addons specific A meta element has been removed from a document. DOMWillOpenModalDialog Addons specific A modal dialog is about to open. DOMModalDialogClosed Addons specific A modal dialog has been closed. DOMAutoComplete Addons specific The content of an element has been auto-completed. DOMFrameContentLoaded Addons specific The frame has finished loading (but not its dependent resources). AlertActive Addons specific A notification element is shown. AlertClose Addons specific A notification element is closed. fullscreen Addons specific Browser fullscreen mode has been entered or left. sizemodechange Addons specific Window has entered/left fullscreen mode, or has been minimized/unminimized. MozEnteredDomFullscreen Addons specific DOM fullscreen mode has been entered. SSWindowClosing Addons specific The session store will stop tracking this window. SSTabClosing Addons specific The session store will stop tracking this tab. SSTabRestoring Addons specific A tab is about to be restored. SSTabRestored Addons specific A tab has been restored. SSWindowStateReady Addons specific A window state has switched to “ready”. SSWindowStateBusy Addons specific A window state has switched to “busy”. TabOpen Addons specific A tab has been opened. TabClose Addons specific A tab has been closed. TabSelect Addons specific A tab has been selected. TabShow Addons specific A tab has been shown. TabHide Addons specific A tab has been hidden. TabPinned Addons specific A tab has been pinned. TabUnpinned Addons specific A tab has been unpinned. ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:44","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"开发者工具特定事件 Event Name Event Type Specification Fired when… CssRuleViewRefreshed devtools specific The “Rules” view of the style inspector has been updated. CssRuleViewChanged devtools specific The “Rules” view of the style inspector has been changed. CssRuleViewCSSLinkClicked devtools specific A link to a CSS file has been clicked in the “Rules” view of the style inspector. 转载自：vue中v-on支持的事件总结 - torchstar - 博客园 (cnblogs.com) ","date":"2021-08-02","objectID":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/:0:45","tags":["Vue"],"title":"Vue中v-on事件总结","uri":"/posts/20210802-vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["前端篇"],"content":"vue项目中，从一个组件获取图片url，并为另一个组件设置该图片为背景的盒子 子组件 \u003ctemplate\u003e \u003cdiv class=\"intd_content_banner\" :style=\"{background:'url('+banner.url+')'}\"\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { props:['banner'], name: \"Banner\", } \u003c/script\u003e 父组件 \u003ctemplate\u003e \u003cdiv id=\"intro\"\u003e \u003cBanner :banner=\"banner\"\u003e\u003c/Banner\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Banner from \"./common/Banner\"; export default { name: \"Intro\", data(){ return{ banner:{ title:'博音简介', url:'https://liangcheng-law.oss-cn-beijing.aliyuncs.com/static/images/lawyer_banner.jpg', } } }, components: {Banner} } \u003c/script\u003e 最近在做vue项目时遇到的小问题，特此记录，下次遇到可以更好解决。（一） ","date":"2021-07-31","objectID":"/posts/20210721-vue%E4%B8%A4%E7%BB%84%E9%97%B4%E9%80%9A%E8%BF%87%E4%BC%A0%E5%80%BC%E8%AE%BE%E7%BD%AE%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E8%83%8C%E6%99%AF/:0:0","tags":["Vue"],"title":"Vue两组间通过传值设置另一个组件背景","uri":"/posts/20210721-vue%E4%B8%A4%E7%BB%84%E9%97%B4%E9%80%9A%E8%BF%87%E4%BC%A0%E5%80%BC%E8%AE%BE%E7%BD%AE%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E8%83%8C%E6%99%AF/"},{"categories":["前端篇"],"content":" // 输出什么？ const myFunc = ({ x, y, z }) =\u003e { console.log(x, y, z); }; myFunc(1, 2, 3); A: 1 2 3 B: {1: 1} {2: 2} {3: 3} C: { 1: undefined } undefined undefined D: undefined undefined undefined 解析： 答案: D myFunc 期望接收一个包含 x, y 和 z 属性的对象作为它的参数。因为我们仅仅传递三个单独的数字值 (1, 2, 3) 而不是一个含有 x, y 和 z 属性的对象 ({x: 1, y: 2, z: 3})， x, y 和 z 有着各自的默认值 undefined. -来源：Github - Javascript Questions ","date":"2021-07-23","objectID":"/posts/20210723-js%E9%97%AE%E9%A2%981/:0:1","tags":["JavaScript"],"title":"JsQuestions-1","uri":"/posts/20210723-js%E9%97%AE%E9%A2%981/"},{"categories":["版本管理"],"content":"Git学习Ⅰ 1.配置作者信息 $ mkdir git 创建文件夹 $ ll 显示 目录列表 $ pwd 看当前在那个文件夹 $ cd 会文件夹目录 $ cd ..后退 $ ls -a 看见隐藏文件 $ git config --global user.email \"xxx@xxx.com\" $ git config --global user.name \"xxx\" $ rm -rm 删除文件夹 $ git clone https://github.com/xxx/xxx.git 克隆存在的项目 2.流水线操作 3.使用命令完成流水操作 $ touch xxx.txt 创建文件 $ git add xxx.txt 将文件放入小推车（暂存） $ git status 查看库的文件状态 $ git add .传入所有文件 $ git commit -m 'xxx' 向git库传入文件并说明 4.gitignore详解控制版本库文件管理 在gitignore中控制上传文件（.gitignore中是忽略文件） $ git .gitignore 5.从版本库中删除资源 $ git rm file 删除库中及本第文件 $ git rm --cached file 仅仅删除本地文件 6.版本库中修改资料名称 $ git mv xxx.txt changeName.txt 修改名字 $ git commit -m 'add file' 上传暂存区的文件 $ git mv indexController.txt IndexController.txt 已存在文件的名字修改 在文件夹中修改名称也需要重新提交 07.使用log日志查看历史记录 $ git log -p 显示文件变动 $ git log --name-only 只显示名字 $ git log -p -1 显示行数 08.使用amend修改最新一次提交事件 $ git commit --amend 进入vim界面修改日志信息 i：insert 插入信息 esc：退出插入 :wq：保存编辑并推出Vim 9.管理暂存区中的文件 $ git rm --cached xxx.txt 文件没有提交 从暂存区撤回 $ git reset xxx.txt 文件已经提交 从暂存区撤销 $ git checkout -- xxx.txt 返回上一次修改内容 回到最初状态 $ cat xxx.txt 查看文件内容 10.alias命令别名提高操作效率 使用alias简化提交指令 [alias] a = add . c = commit l = log s = status 11.git分支branch存在的意义 Git分支是由指针管理起来的，所以创建、切换、合并、删除分支都非常快，非常适合大型项目的开发。 在分支上做开发，调试好了后再合并到主分支。那么每个人开发模块式都不会影响到别人。 12.实例讲解分支branch基本操作 $ git branch xxx 创建分支 $ git checkout xxx 切换分支 $ git branch 查看分支 $ git checkout -b xxx 创建并切换分支 创建新功能要创建并切换到新的分支，不污染主分支 13.分支的合并 $ git master xxx 合并分支 $ git branch -d xxx 删除分支 14.分支管理 –merged 和 –no-merged 及分支强制删除操作 $ git branch –merged 查看合并分支 $ git branch –no-merged 查看未合并分支 $ git branch -d xxx 删除分支 $ git branch -D xxx 强制删除分支 15.标准的分支操作工作流 16.stash临时储存区实例讲解 当需要跳到其他分支去完成任务时，如果当前文件不需要提交，可以将当前文件放入暂存区 $ git stash $ git stash list 查看暂存区文件 $ git stash pop 删除暂存区 $ git stash apply stash@{1} 恢复第一个文件，切换某一个文件存储状态 17.git的Tag标签 稳定版 $ git tag 查看标签 $ git tag v1.0 打标签 18.生成zip代码压缩包 $ git archive master --prefix='lyh' --form=zip \u003e xxx.zip 创建压缩包 19.使用系统别名定义git全局指令 alias gs=\"git status\"alias gc=\"git commit -m\"alias gl=\"git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit \"alias gb=\"git branch\"alias gb=\"git branch\"alias ga=\"git add\"alias go=\"git checkout\" ","date":"2021-07-21","objectID":"/posts/20210721-%E5%88%9D%E8%AF%86git/:0:0","tags":["Git"],"title":"初识Git","uri":"/posts/20210721-%E5%88%9D%E8%AF%86git/"},{"categories":["前端篇"],"content":"随着互联网的快速发展,基于网页的应用越来越普遍,同时也变的越来越复杂,为了满足各种各样的需求,会经常性在本地存储大量的数据, HTML5规范提出了相关解决方案。 本地存储特性 1、数据存储在用户浏览器中 2、设置、读取方便、甚至页面刷新不失数据 3、容量较大, 储存大小约为5MB 4、只能存储字符串,可以将对象JSON.stringifyO编码后存储 先说一下sessionStorage和localStorage两者的区别 前者是一个前端概念，可以将一部分数据在当前会话中保存下来，刷新页面数据依然存在，但关闭页面或者浏览器后数据会被清空。 后者本地存储除非被手动清除否则永久保存 这两者也有相同点，它们存放的数据大小一般为5MB且都是仅在客户端（即浏览器）中保存，不参与和服务器的通信 window.sessionStorage 1.生命周期为关闭浏览器窗口 2.在同一个窗口（页面）下数据可以共享 3.以键值对的形式储存使用 存储数据：window.sessionStorage（key，value） 保存数据语法： sessionStorage.setItem(\"key\", \"value\"); 读取数据语法： var lastname = sessionStorage.getItem(\"key\"); 删除指定键的数据语法： sessionStorage.removeItem(\"key\"); 删除所有数据： sessionStorage.clear(); window.localStorage 1.生命周期永久生效,除非手动删除否则关闭页面也会存在 2、可以多窗口(同一浏览器可以共享) 3.以键值对的形式存储使用 保存数据语法： localStorage.setItem(\"key\", \"value\"); 读取数据语法： var lastname = localStorage.getItem(\"key\"); 删除数据语法： localStorage.removeItem(\"key\"); ","date":"2021-07-19","objectID":"/posts/20210719-html5%E4%B8%AD%E7%9A%84session-storage%E5%92%8Clocal-storage/:0:0","tags":["JavaScript","Html5"],"title":"html5中的sessionstorage和localstorage","uri":"/posts/20210719-html5%E4%B8%AD%E7%9A%84session-storage%E5%92%8Clocal-storage/"},{"categories":["前端篇"],"content":"border-radius - 指定每个圆角 如果你在 border-radius 属性中只指定一个值，那么将生成 4 个 圆角。 但是，如果你要在四个角上一一指定，可以使用以下规则： 四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。 三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角 一个值： 四个圆角值相同 border-radius 所有四个边角 border-*-*-radius 属性的缩写 border-top-left-radius 定义了左上角的弧度 border-top-right-radius 定义了右上角的弧度 border-bottom-right-radius 定义了右下角的弧度 border-bottom-left-radius 定义了左下角的弧度 其中该属性的数值可以是百分比，也可以是其他单位例如像素 ","date":"2021-07-18","objectID":"/posts/20210718-border-radius/:0:0","tags":["Css"],"title":"border-radius","uri":"/posts/20210718-border-radius/"},{"categories":null,"content":"初始化网站 hugo new site [项目名称] ","date":"0001-01-01","objectID":"/drafts/readme/:0:1","tags":null,"title":"","uri":"/drafts/readme/"},{"categories":null,"content":"开启服务 hugo server -D ","date":"0001-01-01","objectID":"/drafts/readme/:0:2","tags":null,"title":"","uri":"/drafts/readme/"},{"categories":null,"content":"添加文章 hugo new posts/博客.md ","date":"0001-01-01","objectID":"/drafts/readme/:0:3","tags":null,"title":"","uri":"/drafts/readme/"},{"categories":null,"content":"打包发布 hugo ","date":"0001-01-01","objectID":"/drafts/readme/:0:4","tags":null,"title":"","uri":"/drafts/readme/"},{"categories":null,"content":"文章内容 标题为三级标题 ### ","date":"0001-01-01","objectID":"/drafts/readme/:0:5","tags":null,"title":"","uri":"/drafts/readme/"}]